{
    "sourceFile": "App/Utils/Visualizer.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1745161088380,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1745161088380,
            "name": "Commit-0",
            "content": "import numpy as np\r\nimport plotly.graph_objects as go\r\nfrom scipy.spatial import ConvexHull\r\nimport logging\r\nimport traceback\r\n\r\n\r\nclass Visualizer:\r\n    \"\"\"\r\n    A modern visualization class using Plotly for interactive 3D visualization\r\n    of cube/pile representations with volume, mass and density information.\r\n    \"\"\"\r\n\r\n    def __init__(self, logging_level=logging.INFO):\r\n        \"\"\"\r\n        Initialize the CubeVisualizer.\r\n\r\n        Args:\r\n            logging_level: The logging level for the visualizer\r\n        \"\"\"\r\n        # Configure logging\r\n        logging.basicConfig(\r\n            level=logging_level,\r\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\r\n        )\r\n        self.logger = logging.getLogger(\"CubeVisualizer\")\r\n\r\n        # Store the latest data for potential reuse\r\n        self._latest_vertices = None\r\n        self._latest_volume = None\r\n        self._latest_density = None\r\n        self._latest_mass = None\r\n\r\n        # Initialize figure\r\n        self.fig = None\r\n\r\n    def process_data_from_modules(self, segmentation_result=None, processed_image=None, calculation_result=None):\r\n        \"\"\"\r\n        Process data from other modules and prepare it for visualization.\r\n\r\n        Args:\r\n            segmentation_result: Result from segmentation.py (e.g., mask or segmented points)\r\n            processed_image: Result from imageprocessor.py (e.g., processed point cloud)\r\n            calculation_result: Result from calculation.py (e.g., dict with volume, density, mass)\r\n\r\n        Returns:\r\n            dict: Processed data ready for visualization\r\n        \"\"\"\r\n        vertices = None\r\n        volume = None\r\n        density = None\r\n        mass = None\r\n\r\n        try:\r\n            # Process segmentation data (if available)\r\n            if segmentation_result is not None:\r\n                if hasattr(segmentation_result, 'points'):\r\n                    vertices = np.array(segmentation_result.points)\r\n                elif isinstance(segmentation_result, dict) and 'points' in segmentation_result:\r\n                    vertices = np.array(segmentation_result['points'])\r\n                self.logger.info(\r\n                    f\"Processed segmentation data with {len(vertices) if vertices is not None else 0} points\")\r\n\r\n            # Process image processing data (if available)\r\n            if processed_image is not None:\r\n                if hasattr(processed_image, 'vertices'):\r\n                    vertices = np.array(processed_image.vertices)\r\n                elif isinstance(processed_image, dict) and 'vertices' in processed_image:\r\n                    vertices = np.array(processed_image['vertices'])\r\n                elif hasattr(processed_image, 'points'):\r\n                    vertices = np.array(processed_image.points)\r\n                elif isinstance(processed_image, dict) and 'points' in processed_image:\r\n                    vertices = np.array(processed_image['points'])\r\n                self.logger.info(f\"Processed image data with {len(vertices) if vertices is not None else 0} points\")\r\n\r\n            # Process calculation data\r\n            if calculation_result is not None:\r\n                if hasattr(calculation_result, 'volume'):\r\n                    volume = calculation_result.volume\r\n                    density = getattr(calculation_result, 'density', None)\r\n                    mass = getattr(calculation_result, 'mass', None)\r\n                elif isinstance(calculation_result, dict):\r\n                    volume = calculation_result.get('volume')\r\n                    density = calculation_result.get('density')\r\n                    mass = calculation_result.get('mass')\r\n                self.logger.info(f\"Processed calculation data: volume={volume}, density={density}, mass={mass}\")\r\n\r\n            # Store the data for potential reuse\r\n            if vertices is not None:\r\n                self._latest_vertices = vertices\r\n            if volume is not None:\r\n                self._latest_volume = volume\r\n            if density is not None:\r\n                self._latest_density = density\r\n            if mass is not None:\r\n                self._latest_mass = mass\r\n\r\n            return {\r\n                'vertices': vertices,\r\n                'volume': volume,\r\n                'density': density,\r\n                'mass': mass\r\n            }\r\n\r\n        except Exception as e:\r\n            self.logger.error(f\"Error processing module data: {str(e)}\\n{traceback.format_exc()}\")\r\n            return None\r\n\r\n    def plot_cube(self, corners_3d, volume=None, density=None, mass=None):\r\n        \"\"\"\r\n        Plot a 3D cube or convex hull based on the given corners and display its properties.\r\n\r\n        Args:\r\n            corners_3d: 3D coordinates of cube corners or point cloud, shape (n, 3)\r\n            volume: Volume of the object in cubic meters\r\n            density: Density of the object in kg/m³\r\n            mass: Mass of the object in kg\r\n        \"\"\"\r\n        # Use latest data if not provided\r\n        if corners_3d is None and self._latest_vertices is not None:\r\n            corners_3d = self._latest_vertices\r\n            self.logger.info(\"Using latest stored vertices\")\r\n\r\n        if volume is None and self._latest_volume is not None:\r\n            volume = self._latest_volume\r\n            self.logger.info(\"Using latest stored volume\")\r\n\r\n        if density is None and self._latest_density is not None:\r\n            density = self._latest_density\r\n            self.logger.info(\"Using latest stored density\")\r\n\r\n        if mass is None and self._latest_mass is not None:\r\n            mass = self._latest_mass\r\n            self.logger.info(\"Using latest stored mass\")\r\n\r\n        # Validate required data\r\n        if corners_3d is None:\r\n            self.logger.error(\"No corner points provided for visualization\")\r\n            return\r\n\r\n        corners = np.array(corners_3d)\r\n\r\n        # Remove duplicate points and ensure we have enough unique points\r\n        unique_corners = np.unique(corners, axis=0)\r\n        if len(unique_corners) < 4:  # Need at least 4 points for a 3D hull\r\n            self.logger.error(f\"Insufficient unique points for 3D visualization: {len(unique_corners)} points\")\r\n            # Create a scatter plot of the points\r\n            self.fig = go.Figure(data=[\r\n                go.Scatter3d(\r\n                    x=unique_corners[:, 0],\r\n                    y=unique_corners[:, 1],\r\n                    z=unique_corners[:, 2],\r\n                    mode='markers',\r\n                    marker=dict(\r\n                        size=8,\r\n                        color='red',\r\n                        opacity=0.8\r\n                    ),\r\n                    name='Vertices'\r\n                )\r\n            ])\r\n            return\r\n\r\n        try:\r\n            # Create convex hull for visualization\r\n            hull = ConvexHull(unique_corners)\r\n\r\n            # Plot points\r\n            points_trace = go.Scatter3d(\r\n                x=unique_corners[:, 0],\r\n                y=unique_corners[:, 1],\r\n                z=unique_corners[:, 2],\r\n                mode='markers',\r\n                marker=dict(\r\n                    size=8,\r\n                    color='red',\r\n                    opacity=0.8\r\n                ),\r\n                name='Vertices'\r\n            )\r\n\r\n            # Create mesh data for plotting the hull\r\n            faces = []\r\n            for simplex in hull.simplices:\r\n                faces.append(simplex)\r\n\r\n            # Convert faces to the format required by Plotly\r\n            i = []\r\n            j = []\r\n            k = []\r\n\r\n            for face in faces:\r\n                if len(face) >= 3:  # Ensure the face has at least 3 points\r\n                    i.append(face[0])\r\n                    j.append(face[1])\r\n                    k.append(face[2])\r\n\r\n            # Plot the mesh\r\n            mesh_trace = go.Mesh3d(\r\n                x=unique_corners[:, 0],\r\n                y=unique_corners[:, 1],\r\n                z=unique_corners[:, 2],\r\n                i=i, j=j, k=k,\r\n                opacity=0.3,\r\n                color='blue',\r\n                name='Hull'\r\n            )\r\n\r\n            # Calculate and display hull volume if not provided\r\n            if volume is None:\r\n                volume = hull.volume\r\n                self.logger.info(f\"Calculated volume from hull: {volume}\")\r\n                self._latest_volume = volume\r\n\r\n            # Create a figure with both traces\r\n            self.fig = go.Figure(data=[points_trace, mesh_trace])\r\n\r\n            # --- Update Title Generation ---\r\n            title_parts = [\"3D Visualization\"]\r\n            if volume is not None: title_parts.append(f\"Volume: {volume:.4f} m³\")  # Increased precision\r\n            if mass is not None: title_parts.append(f\"Mass: {mass:.2f} kg\")\r\n            if density is not None: title_parts.append(f\"Density: {density:.1f} kg/m³\")\r\n            # --- End Update ---\r\n\r\n            self.fig.update_layout(\r\n                title='<br>'.join(title_parts),  # Join parts with line breaks\r\n                scene=dict(\r\n                    xaxis_title='Width (m)',\r\n                    yaxis_title='Depth (m)',\r\n                    zaxis_title='Height (m)',\r\n                    aspectmode='data'\r\n                ),\r\n                margin=dict(l=0, r=0, b=0, t=80)  # Increased top margin for multi-line title\r\n            )\r\n            self.logger.info(\"3D plot generated successfully.\")\r\n\r\n        except Exception as e:\r\n            self.logger.error(f\"Error generating 3D plot: {e}\", exc_info=True)\r\n            self.fig = None\r\n\r\n    def display_mesh(self, mesh):\r\n        \"\"\"\r\n        Display a mesh object with its volume.\r\n\r\n        Args:\r\n            mesh: The mesh object containing vertices and volume information\r\n        \"\"\"\r\n        try:\r\n            if not mesh:\r\n                raise ValueError(\"Mesh object cannot be None\")\r\n\r\n            # Check for vertices\r\n            vertices = None\r\n            if hasattr(mesh, 'vertices'):\r\n                vertices = np.asarray(mesh.vertices)\r\n            elif hasattr(mesh, 'get_vertices'):\r\n                vertices = np.asarray(mesh.get_vertices())\r\n            elif hasattr(mesh, 'points'):\r\n                vertices = np.asarray(mesh.points)\r\n            else:\r\n                raise ValueError(\"Mesh object must have vertices attribute or method to get vertices\")\r\n\r\n            # Check for volume\r\n            volume = None\r\n            if hasattr(mesh, 'volume'):\r\n                volume = mesh.volume\r\n            elif hasattr(mesh, 'compute_volume'):\r\n                volume = mesh.compute_volume()\r\n            elif hasattr(mesh, 'get_volume'):\r\n                volume = mesh.get_volume()\r\n            else:\r\n                # Estimate volume from vertices\r\n                hull = ConvexHull(vertices)\r\n                volume = hull.volume\r\n                self.logger.info(f\"Estimated volume from vertices: {volume}\")\r\n\r\n            # Check for other properties\r\n            density = getattr(mesh, 'density', None)\r\n            mass = getattr(mesh, 'mass', None)\r\n\r\n            # Store data for potential reuse\r\n            self._latest_vertices = vertices\r\n            self._latest_volume = volume\r\n            self._latest_density = density\r\n            self._latest_mass = mass\r\n\r\n            self.plot_cube(vertices, volume, density, mass)\r\n\r\n        except Exception as e:\r\n            self.logger.error(f\"Failed to display mesh: {str(e)}\\n{traceback.format_exc()}\")\r\n            raise\r\n\r\n    def visualize_from_calculation_result(self, calculation_result):\r\n        \"\"\"\r\n        Visualize based on a calculation result from calculation.py\r\n\r\n        Args:\r\n            calculation_result: Dict or object with volume, density, mass, and vertices/points\r\n        \"\"\"\r\n        try:\r\n            # Process the calculation result\r\n            data = self.process_data_from_modules(calculation_result=calculation_result)\r\n            if data and data['vertices'] is not None:\r\n                self.plot_cube(\r\n                    data['vertices'],\r\n                    data['volume'],\r\n                    data['density'],\r\n                    data['mass']\r\n                )\r\n            else:\r\n                self.logger.error(\"Insufficient data from calculation result for visualization\")\r\n        except Exception as e:\r\n            self.logger.error(f\"Failed to visualize from calculation result: {str(e)}\\n{traceback.format_exc()}\")\r\n\r\n    def visualize_from_segmentation(self, segmentation_result, calculation_result=None):\r\n        \"\"\"\r\n        Visualize based on segmentation results from segmentation.py\r\n\r\n        Args:\r\n            segmentation_result: Result from segmentation.py with points/vertices\r\n            calculation_result: Optional calculation results with volume, density, mass\r\n        \"\"\"\r\n        try:\r\n            # Process the segmentation and calculation results\r\n            data = self.process_data_from_modules(\r\n                segmentation_result=segmentation_result,\r\n                calculation_result=calculation_result\r\n            )\r\n\r\n            if data and data['vertices'] is not None:\r\n                self.plot_cube(\r\n                    data['vertices'],\r\n                    data['volume'],\r\n                    data['density'],\r\n                    data['mass']\r\n                )\r\n            else:\r\n                self.logger.error(\"Insufficient data from segmentation for visualization\")\r\n        except Exception as e:\r\n            self.logger.error(f\"Failed to visualize from segmentation: {str(e)}\\n{traceback.format_exc()}\")\r\n\r\n    def visualize_from_image_processor(self, processed_image, calculation_result=None):\r\n        \"\"\"\r\n        Visualize based on processed image results from imageprocessor.py\r\n\r\n        Args:\r\n            processed_image: Result from imageprocessor.py with points/vertices\r\n            calculation_result: Optional calculation results with volume, density, mass\r\n        \"\"\"\r\n        try:\r\n            # Process the image processing and calculation results\r\n            data = self.process_data_from_modules(\r\n                processed_image=processed_image,\r\n                calculation_result=calculation_result\r\n            )\r\n\r\n            if data and data['vertices'] is not None:\r\n                self.plot_cube(\r\n                    data['vertices'],\r\n                    data['volume'],\r\n                    data['density'],\r\n                    data['mass']\r\n                )\r\n            else:\r\n                self.logger.error(\"Insufficient data from image processor for visualization\")\r\n        except Exception as e:\r\n            self.logger.error(f\"Failed to visualize from image processor: {str(e)}\\n{traceback.format_exc()}\")\r\n\r\n    def update_visualization(self, **kwargs):\r\n        \"\"\"\r\n        Update the visualization with new data.\r\n\r\n        Kwargs:\r\n            vertices or points: 3D coordinates for visualization\r\n            volume: Updated volume value\r\n            density: Updated density value\r\n            mass: Updated mass value\r\n        \"\"\"\r\n        vertices = kwargs.get('vertices') or kwargs.get('points')\r\n        volume = kwargs.get('volume')\r\n        density = kwargs.get('density')\r\n        mass = kwargs.get('mass')\r\n\r\n        # Update stored values for any provided parameters\r\n        if vertices is not None:\r\n            self._latest_vertices = np.array(vertices)\r\n        if volume is not None:\r\n            self._latest_volume = volume\r\n        if density is not None:\r\n            self._latest_density = density\r\n        if mass is not None:\r\n            self._latest_mass = mass\r\n\r\n        # Plot with latest data (will use stored values for any not provided)\r\n        self.plot_cube(self._latest_vertices, self._latest_volume,\r\n                       self._latest_density, self._latest_mass)\r\n\r\n    def show(self, height=800, width=1000):\r\n        \"\"\"\r\n        Display the visualization.\r\n\r\n        Args:\r\n            height: Height of the plot in pixels\r\n            width: Width of the plot in pixels\r\n        \"\"\"\r\n        if self.fig is None:\r\n            self.logger.error(\"No visualization to show. Call plot_cube() first.\")\r\n            return\r\n\r\n        self.fig.update_layout(\r\n            autosize=False,\r\n            width=width,\r\n            height=height\r\n        )\r\n        self.fig.show()\r\n\r\n    def save_figure(self, filename, width=1200, height=800):\r\n        \"\"\"\r\n        Save the visualization to a file.\r\n\r\n        Args:\r\n            filename: The filename to save to (include extension like .png, .jpg, .html)\r\n            width: Width of the saved image in pixels\r\n            height: Height of the saved image in pixels\r\n        \"\"\"\r\n        try:\r\n            if self.fig is None:\r\n                self.logger.error(\"No visualization to save. Call plot_cube() first.\")\r\n                return\r\n\r\n            # Set dimensions for the saved figure\r\n            self.fig.update_layout(\r\n                autosize=False,\r\n                width=width,\r\n                height=height\r\n            )\r\n\r\n            if filename.endswith('.html'):\r\n                self.fig.write_html(filename)\r\n                self.logger.info(f\"Interactive HTML figure saved to {filename}\")\r\n            else:\r\n                self.fig.write_image(filename)\r\n                self.logger.info(f\"Static image saved to {filename}\")\r\n        except Exception as e:\r\n            self.logger.error(f\"Failed to save figure: {str(e)}\\n{traceback.format_exc()}\")"
        }
    ]
}