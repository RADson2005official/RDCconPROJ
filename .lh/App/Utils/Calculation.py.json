{
    "sourceFile": "App/Utils/Calculation.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1745148027297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745152102450,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,513 +1,129 @@\n import numpy as np\r\n import logging\r\n import cv2\r\n from typing import Dict, Optional, Tuple, List, Union\r\n+from scipy.spatial import ConvexHull  # Example: If using convex hull for volume\r\n \r\n+logger = logging.getLogger(__name__)\r\n \r\n-class Calculation:\r\n-    \"\"\"\r\n-    Enhanced calculation class for material volume and mass calculations.\r\n-    This class combines the functionality from the original Calculation class\r\n-    and key calculations from MaterialProperties.\r\n-    \"\"\"\r\n+# --- Placeholder Density Values (kg/m³) ---\r\n+# These should ideally come from user input or a configuration file\r\n+MATERIAL_DENSITIES = {\r\n+    \"Sand\": 1600,\r\n+    \"10mm Gravel\": 1500,\r\n+    \"20mm Gravel\": 1550,\r\n+    \"Default\": 1550  # Fallback\r\n+}\r\n \r\n-    # Define comprehensive material densities (kg/m³)\r\n-    MATERIAL_DENSITIES = {\r\n-        'Sand': {\r\n-            'Dry': 1600.0,\r\n-            'Wet': 1900.0,\r\n-            'Compacted': 2000.0\r\n-        },\r\n-        'Gravel': {\r\n-            'Loose': 1600.0,\r\n-            'Compacted': 1900.0,\r\n-            'Crushed': 1650.0,\r\n-            'Wet': 1800.0,\r\n-            'Dry': 1500.0\r\n-        },\r\n-        'Soil': {\r\n-            'Dry': 1300.0,\r\n-            'Wet': 1700.0,\r\n-            'Compacted': 1900.0\r\n-        },\r\n-        'Rock': {\r\n-            'Crushed': 1600.0,\r\n-            'Solid': 2700.0,\r\n-            'Wet': 2800.0\r\n-        },\r\n-        'Concrete': {\r\n-            'Regular': 2400.0,\r\n-            'Reinforced': 2500.0,\r\n-            'Fresh': 2350.0\r\n-        },\r\n-        'Other': 1800.0  # Default density\r\n-    }\r\n+def get_density(material_type: str = \"Default\") -> float:\r\n+    \"\"\"Gets the density for a given material type.\"\"\"\r\n+    density = MATERIAL_DENSITIES.get(material_type, MATERIAL_DENSITIES[\"Default\"])\r\n+    logger.info(f\"Using density for '{material_type}': {density} kg/m³\")\r\n+    return density\r\n \r\n-    # Define material specific gravity ranges\r\n-    MATERIAL_SPECIFIC_GRAVITY_RANGES = {\r\n-        \"Sand\": (2.65, 2.67),\r\n-        \"Gravel\": (2.5, 3.0),\r\n-        \"Concrete\": (2.3, 2.5),\r\n-        \"Soil\": (1.1, 1.3),\r\n-        \"Unknown\": (0, 0)\r\n-    }\r\n-\r\n-    def __init__(self):\r\n-        self.logger = logging.getLogger(__name__)\r\n-        self.logger.setLevel(logging.INFO)\r\n-        if not self.logger.handlers:\r\n-            handler = logging.StreamHandler()\r\n-            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\n-            handler.setFormatter(formatter)\r\n-            self.logger.addHandler(handler)\r\n-\r\n-        self.calibrated_densities = {}\r\n-        self.measurement_history = []\r\n-        self.MAX_HISTORY_SIZE = 10\r\n-\r\n-    def calculate_volume(self, volume_value: float, material_type: str = \"Sand\",\r\n-                         condition: str = None, material_density: Optional[float] = None,\r\n-                         known_mass: Optional[float] = None) -> Dict[str, float]:\r\n-        \"\"\"\r\n-        Volume and mass calculation with enhanced material property support\r\n-\r\n-        Args:\r\n-            volume_value: The volume value in m³\r\n-            material_type: Type of material (\"Sand\", \"Gravel\", \"Concrete\", \"Soil\", etc.)\r\n-            condition: Material condition (e.g., 'Dry', 'Wet', 'Compacted')\r\n-            material_density: Optional explicit density value in kg/m³\r\n-            known_mass: Optional known mass in kg for calibration\r\n-\r\n-        Returns:\r\n-            Dict with volume calculation results\r\n-        \"\"\"\r\n-        try:\r\n-            # Validate the calculated volume\r\n-            if volume_value <= 0 or np.isnan(volume_value) or np.isinf(volume_value):\r\n-                self.logger.error(f\"Invalid volume calculation result: {volume_value}\")\r\n-                return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n-                        \"condition\": condition, \"density\": 0.0,\r\n-                        \"error\": \"Invalid volume value\"}\r\n-\r\n-            # Get density using proper logic\r\n-            if material_density is not None:\r\n-                # Use explicitly provided density\r\n-                self.logger.info(f\"Using explicitly provided density: {material_density} kg/m³\")\r\n-            elif known_mass is not None:\r\n-                # Calibrate density using the known mass\r\n-                material_density = self.calibrate_density(known_mass, volume_value, material_type)\r\n-                self.logger.info(f\"Using calibrated density: {material_density} kg/m³\")\r\n-            else:\r\n-                # Use enhanced get_material_density method\r\n-                material_density = self.get_material_density(material_type, condition)\r\n-                self.logger.info(f\"Using material density for {material_type} ({condition}): {material_density} kg/m³\")\r\n-\r\n-            # Calculate mass in metric tons\r\n-            mass = self.calculate_mass(volume_value, material_type, condition, material_density)\r\n-\r\n-            # Store result in history for consistency checking\r\n-            result = {\r\n-                \"total\": volume_value,\r\n-                \"mass\": mass,\r\n-                \"material_type\": material_type,\r\n-                \"condition\": condition,\r\n-                \"density\": material_density,\r\n-                \"timestamp\": None,  # Can be filled with actual timestamp if needed\r\n-                \"error\": None\r\n-            }\r\n-\r\n-            # Add to history and maintain maximum size\r\n-            self.measurement_history.append(result)\r\n-            if len(self.measurement_history) > self.MAX_HISTORY_SIZE:\r\n-                self.measurement_history.pop(0)\r\n-\r\n-            # Only perform consistency check if we have enough history\r\n-            if len(self.measurement_history) >= 3:\r\n-                result = self._check_measurement_consistency(result)\r\n-\r\n-            self.logger.info(f\"Final volume calculation: {volume_value:.2f} m³, {mass:.2f} metric tons\")\r\n-            return result\r\n-\r\n-        except Exception as e:\r\n-            self.logger.error(f\"Volume calculation failed: {str(e)}\")\r\n-            return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n-                    \"condition\": condition, \"density\": 0.0,\r\n-                    \"error\": f\"Exception: {str(e)}\"}\r\n-\r\n-    def get_material_density(self, material_type: str, condition: str = None) -> float:\r\n-        \"\"\"\r\n-        Get the density of a material based on its type and condition.\r\n-\r\n-        Args:\r\n-            material_type (str): Type of material (e.g., 'Sand', 'Gravel')\r\n-            condition (str, optional): Condition of material (e.g., 'Dry', 'Wet', 'Compacted')\r\n-\r\n-        Returns:\r\n-            float: Material density in kg/m³\r\n-        \"\"\"\r\n-        try:\r\n-            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n-\r\n-            # If material type not found, return default density\r\n-            if material_type not in self.MATERIAL_DENSITIES:\r\n-                self.logger.warning(f\"Unknown material type: {material_type}, using default density\")\r\n-                return self.MATERIAL_DENSITIES['Other']\r\n-\r\n-            material_data = self.MATERIAL_DENSITIES[material_type]\r\n-\r\n-            # If no condition specified or invalid condition, return average density\r\n-            if not condition or not isinstance(material_data, dict):\r\n-                return sum(material_data.values()) / len(material_data)\r\n-\r\n-            condition = condition.strip().capitalize() if condition else None\r\n-            if condition in material_data:\r\n-                density = material_data[condition]\r\n-            else:\r\n-                # Return average if condition not found\r\n-                self.logger.warning(f\"Unknown condition: {condition} for {material_type}, using average density\")\r\n-                density = sum(material_data.values()) / len(material_data)\r\n-\r\n-            # Calculate specific gravity\r\n-            specific_gravity = density / 1000  # Convert kg/m³ to specific gravity (water density = 1000 kg/m³)\r\n-\r\n-            # Validate specific gravity against known ranges\r\n-            if material_type in self.MATERIAL_SPECIFIC_GRAVITY_RANGES:\r\n-                min_sg, max_sg = self.MATERIAL_SPECIFIC_GRAVITY_RANGES[material_type]\r\n-                if not (min_sg <= specific_gravity <= max_sg):\r\n-                    self.logger.warning(\r\n-                        f\"Specific gravity {specific_gravity} for {material_type} is outside expected range ({min_sg}-{max_sg})\")\r\n-\r\n-            return density\r\n-\r\n-        except Exception as e:\r\n-            self.logger.error(f\"Error getting material density: {str(e)}\")\r\n-            return self.MATERIAL_DENSITIES['Other']\r\n-\r\n-    def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n-                       density: Optional[float] = None) -> float:\r\n-        \"\"\"\r\n-        Calculate mass based on volume and material type.\r\n-\r\n-        Args:\r\n-            volume (float): Volume in cubic meters\r\n-            material_type (str): Type of material\r\n-            condition (str, optional): Condition of material\r\n-            density (float, optional): Override density if provided\r\n-\r\n-        Returns:\r\n-            float: Mass in metric tons\r\n-        \"\"\"\r\n-        if density is None:\r\n-            density = self.get_material_density(material_type, condition)\r\n-        return volume * density / 1000.0  # Convert to metric tons\r\n-\r\n-    def calibrate_density(self, known_mass: float, measured_volume: float, material_type: str = \"Sand\") -> float:\r\n-        \"\"\"\r\n-        Simple density calibration based on known mass and measured volume\r\n-\r\n-        Args:\r\n-            known_mass (float): Known mass in kg.\r\n-            measured_volume (float): Measured volume in m³.\r\n-            material_type (str): Type of material being calibrated.\r\n-        Returns:\r\n-            float: Calibrated density in kg/m³.\r\n-        \"\"\"\r\n-        if measured_volume <= 0:\r\n-            self.logger.error(\"Cannot calibrate with zero or negative volume\")\r\n-            return self.get_material_density(material_type)\r\n-\r\n-        # Use the actual measured mass/volume for calibration\r\n-        calibrated_density = known_mass / measured_volume\r\n-\r\n-        # Store the calibrated density\r\n-        self.calibrated_densities[material_type] = calibrated_density\r\n-\r\n-        self.logger.info(f\"Calibration for {material_type}:\")\r\n-        self.logger.info(f\"- Calibrated density: {calibrated_density:.2f} kg/m³\")\r\n-\r\n-        return calibrated_density\r\n-\r\n-    def _check_measurement_consistency(self, current_result: Dict[str, float]) -> Dict[str, float]:\r\n-        \"\"\"Check if current measurement is consistent with recent history\"\"\"\r\n-        # Extract recent volumes and masses\r\n-        recent_volumes = [r[\"total\"] for r in self.measurement_history[-3:] if \"total\" in r]\r\n-        recent_masses = [r[\"mass\"] for r in self.measurement_history[-3:] if \"mass\" in r and r[\"mass\"] is not None]\r\n-\r\n-        if not recent_volumes or not recent_masses:\r\n-            return current_result\r\n-\r\n-        # Calculate mean and standard deviation\r\n-        mean_volume = np.mean(recent_volumes)\r\n-        std_volume = np.std(recent_volumes)\r\n-        mean_mass = np.mean(recent_masses)\r\n-        std_mass = np.std(recent_masses)\r\n-\r\n-        # Check if current measurement is within reasonable bounds (3 standard deviations)\r\n-        if std_volume > 0 and abs(current_result[\"total\"] - mean_volume) > 3 * std_volume:\r\n-            self.logger.warning(\r\n-                f\"Volume measurement ({current_result['total']:.2f}) deviates significantly from recent average ({mean_volume:.2f}), std: {std_volume:.2f}\")\r\n-            # Apply smoothing\r\n-            current_result[\"total\"] = 0.7 * current_result[\"total\"] + 0.3 * mean_volume\r\n-            self.logger.info(f\"Adjusted volume to {current_result['total']:.2f}\")\r\n-\r\n-        if std_mass > 0 and abs(current_result[\"mass\"] - mean_mass) > 3 * std_mass:\r\n-            self.logger.warning(\r\n-                f\"Mass measurement ({current_result['mass']:.2f}) deviates significantly from recent average ({mean_mass:.2f}), std: {std_mass:.2f}\")\r\n-            # Apply smoothing\r\n-            current_result[\"mass\"] = 0.7 * current_result[\"mass\"] + 0.3 * mean_mass\r\n-            self.logger.info(f\"Adjusted mass to {current_result['mass']:.2f}\")\r\n-\r\n-        return current_result\r\n-\r\n-    def validate_material_properties(self, material_type: str, density: Optional[float] = None) -> Dict:\r\n-        \"\"\"\r\n-        Validate material properties and provide recommendations.\r\n-\r\n-        Args:\r\n-            material_type (str): Type of material\r\n-            density (float, optional): User-provided density\r\n-\r\n-        Returns:\r\n-            Dict: Validation results and recommendations\r\n-        \"\"\"\r\n-        result = {\r\n-            'valid': True,\r\n-            'message': '',\r\n-            'recommended_density': None,\r\n-            'density_range': None\r\n-        }\r\n-\r\n-        try:\r\n-            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n-            if material_type not in self.MATERIAL_DENSITIES:\r\n-                result['valid'] = False\r\n-                result['message'] = f\"Unknown material type: {material_type}\"\r\n-                return result\r\n-\r\n-            material_data = self.MATERIAL_DENSITIES[material_type]\r\n-            densities = list(material_data.values())\r\n-            min_density = min(densities)\r\n-            max_density = max(densities)\r\n-            avg_density = sum(densities) / len(densities)\r\n-\r\n-            result['density_range'] = (min_density, max_density)\r\n-            result['recommended_density'] = avg_density\r\n-\r\n-            if density is not None:\r\n-                if density < min_density * 0.5 or density > max_density * 1.5:\r\n-                    result['valid'] = False\r\n-                    result[\r\n-                        'message'] = f\"Density {density} kg/m³ is outside expected range ({min_density}-{max_density} kg/m³)\"\r\n-                elif density < min_density or density > max_density:\r\n-                    result['message'] = f\"Warning: Density {density} kg/m³ is unusual for {material_type}\"\r\n-\r\n-        except Exception as e:\r\n-            result['valid'] = False\r\n-            result['message'] = f\"Error validating properties: {str(e)}\"\r\n-\r\n-        return result\r\n-\r\n-    def get_material_conditions(self, material_type: str) -> list:\r\n-        \"\"\"\r\n-        Get available conditions for a material type.\r\n-\r\n-        Args:\r\n-            material_type (str): Type of material\r\n-\r\n-        Returns:\r\n-            list: Available conditions for the material\r\n-        \"\"\"\r\n-        try:\r\n-            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n-            if material_type in self.MATERIAL_DENSITIES:\r\n-                return list(self.MATERIAL_DENSITIES[material_type].keys())\r\n-            return []\r\n-        except Exception:\r\n-            return []\r\n-\r\n-    def get_available_materials(self) -> list:\r\n-        \"\"\"\r\n-        Get list of available material types.\r\n-\r\n-        Returns:\r\n-            list: Available material types\r\n-        \"\"\"\r\n-        return list(self.MATERIAL_DENSITIES.keys())\r\n-\r\n-    def adjust_sand_density(self, base_density: float,\r\n-                            moisture_content: float = 0.0,\r\n-                            compaction_level: str = \"loose\",\r\n-                            sand_type: str = \"standard\") -> float:\r\n-        \"\"\"\r\n-        Adjust sand density based on various factors.\r\n-\r\n-        Args:\r\n-            base_density: Base density in kg/m³\r\n-            moisture_content: Moisture percentage (0-100)\r\n-            compaction_level: \"loose\", \"medium\", or \"dense\"\r\n-            sand_type: Type of sand (\"fine\", \"coarse\", \"standard\")\r\n-\r\n-        Returns:\r\n-            Adjusted density in kg/m³\r\n-        \"\"\"\r\n-        # Moisture adjustment factor\r\n-        moisture_factor = 1 + (moisture_content / 100)\r\n-\r\n-        # Compaction adjustment\r\n-        compaction_factors = {\r\n-            \"loose\": 0.85,\r\n-            \"medium\": 1.0,\r\n-            \"dense\": 1.15\r\n-        }\r\n-        compaction_factor = compaction_factors.get(compaction_level, 1.0)\r\n-\r\n-        # Sand type adjustment\r\n-        sand_type_factors = {\r\n-            \"fine\": 0.95,\r\n-            \"standard\": 1.0,\r\n-            \"coarse\": 1.05\r\n-        }\r\n-        type_factor = sand_type_factors.get(sand_type, 1.0)\r\n-\r\n-        # Calculate adjusted density\r\n-        adjusted_density = base_density * moisture_factor * compaction_factor * type_factor\r\n-\r\n-        self.logger.info(f\"Adjusted sand density: {adjusted_density:.2f} kg/m³ \"\r\n-                         f\"(moisture: {moisture_content}%, compaction: {compaction_level}, type: {sand_type})\")\r\n-\r\n-        return adjusted_density\r\n-\r\n-    def calculate_conical_pile_volume(self, area: float, height: float) -> float:\r\n-        \"\"\"\r\n-        Calculate volume of a conical pile based on base area and height.\r\n-        Conical piles typically have 1/3 the volume of a cylinder with the same base and height.\r\n-\r\n-        Args:\r\n-            area: Base area in m²\r\n-            height: Height in m\r\n-\r\n-        Returns:\r\n-            Volume in m³\r\n-        \"\"\"\r\n-        cone_factor = 1 / 3\r\n-        volume = area * height * cone_factor\r\n-        return volume\r\n-\r\n-    def validate_results(self, calculated_result: Dict[str, float],\r\n-                         ground_truth: Dict[str, float]) -> Dict[str, float]:\r\n-        \"\"\"Calculate accuracy metrics for volume and mass.\"\"\"\r\n-        metrics = {}\r\n-\r\n-        # Validate volume\r\n-        if 'total' in calculated_result and 'volume' in ground_truth:\r\n-            vol_abs_error = abs(calculated_result['total'] - ground_truth['volume'])\r\n-            vol_rel_error = vol_abs_error / ground_truth['volume'] * 100 if ground_truth['volume'] > 0 else float('inf')\r\n-\r\n-            metrics.update({\r\n-                'volume_absolute_error': vol_abs_error,\r\n-                'volume_relative_error': vol_rel_error,\r\n-                'volume_rmse': np.sqrt(vol_abs_error ** 2)\r\n-            })\r\n-\r\n-        # Validate mass if density is provided\r\n-        if 'mass' in calculated_result and 'density' in ground_truth:\r\n-            true_mass = ground_truth['volume'] * ground_truth['density'] / 1000.0\r\n-            mass_abs_error = abs(calculated_result['mass'] - true_mass)\r\n-            mass_rel_error = mass_abs_error / true_mass * 100 if true_mass > 0 else float('inf')\r\n-\r\n-            metrics.update({\r\n-                'mass_absolute_error': mass_abs_error,\r\n-                'mass_relative_error': mass_rel_error,\r\n-                'mass_rmse': np.sqrt(mass_abs_error ** 2)\r\n-            })\r\n-\r\n-        return metrics\r\n-\r\n-\r\n-# Example usage\r\n-if __name__ == \"__main__\":\r\n-    # Configure logging\r\n-    logging.basicConfig(\r\n-        level=logging.INFO,\r\n-        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\r\n-    )\r\n-\r\n-logger = logging.getLogger(__name__)\r\n-\r\n-def calculate_damage(segmentation_result):\r\n+def calculate_volume_mass_density(top_seg_data: dict, front_seg_data: dict, material_type: str = \"Default\"):\r\n     \"\"\"\r\n-    Placeholder function to calculate damage metrics.\r\n-    Replace with your actual damage calculation logic.\r\n+    Placeholder function to calculate volume, mass, and density.\r\n+    Replace with your actual calculation logic using data from both views.\r\n \r\n     Args:\r\n-        segmentation_result: Dictionary containing segmentation data (e.g., mask, contours).\r\n+        top_seg_data: Dictionary containing segmentation results for the top view (e.g., 'mask', 'contours').\r\n+        front_seg_data: Dictionary containing segmentation results for the front view (e.g., 'mask', 'contours').\r\n+        material_type: String indicating the material (e.g., \"Sand\", \"10mm Gravel\").\r\n \r\n     Returns:\r\n-        A dictionary with damage metrics (e.g., {'crack_area_percentage': 5.2})\r\n-        or None if calculation fails.\r\n+        A dictionary containing {'volume': float, 'mass': float, 'density': float, 'points': np.ndarray | None}\r\n+        Returns None if critical calculation fails.\r\n     \"\"\"\r\n-    logger.info(\"Calculating damage (Placeholder)...\")\r\n-    if not segmentation_result or 'mask' not in segmentation_result:\r\n-        logger.warning(\"Invalid segmentation result for damage calculation.\")\r\n+    logger.info(\"Calculating volume, mass, density (Placeholder)...\")\r\n+    if not top_seg_data or not front_seg_data or 'mask' not in top_seg_data or 'mask' not in front_seg_data:\r\n+        logger.warning(\"Missing or invalid segmentation data for calculation.\")\r\n         return None\r\n \r\n-    # --- Placeholder Logic ---\r\n-    # Example: Calculate percentage of mask area relative to total image area\r\n-    mask = segmentation_result['mask']\r\n-    if mask is None or mask.size == 0:\r\n-         logger.warning(\"Mask is empty in segmentation result.\")\r\n-         return {'damage_description': 'No mask found'}\r\n+    volume_m3 = None\r\n+    mass_kg = None\r\n+    points_3d = None  # Placeholder for 3D points for visualization\r\n \r\n-    total_pixels = mask.size\r\n-    damage_pixels = np.count_nonzero(mask)\r\n-    damage_percentage = (damage_pixels / total_pixels) * 100 if total_pixels > 0 else 0\r\n+    try:\r\n+        # --- Placeholder Volume Logic ---\r\n+        top_mask = top_seg_data['mask']\r\n+        front_mask = front_seg_data['mask']\r\n \r\n-    logger.info(f\"Placeholder damage calculated: {damage_percentage:.2f}% area\")\r\n-    # --- End Placeholder ---\r\n+        if top_mask is None or front_mask is None:\r\n+            logger.warning(\"Missing mask in segmentation data.\")\r\n+            return None\r\n \r\n-    # Return results in a dictionary\r\n-    return {\r\n-        'damage_area_percentage': round(damage_percentage, 2),\r\n-        'description': 'Calculated based on segmented mask area (Placeholder)'\r\n-    }\r\n+        # Example: Estimate volume using top area and estimated height from front view\r\n+        top_area_pixels = np.count_nonzero(top_mask)\r\n \r\n+        # --- CRITICAL: Calibration Needed ---\r\n+        # You MUST determine the relationship between pixels and real-world units (e.g., meters)\r\n+        # This depends entirely on your camera setup (distance, lens, etc.)\r\n+        PIXELS_PER_METER_HORIZONTAL = 500  # Example value - MUST BE CALIBRATED\r\n+        PIXELS_PER_METER_VERTICAL = 500    # Example value - MUST BE CALIBRATED\r\n+        # --- End Calibration ---\r\n \r\n-def calculate_volume(top_view_data, front_view_data):\r\n-    \"\"\"\r\n-    Placeholder function to calculate volume based on processed view data.\r\n-    Replace with your actual volume calculation logic using data from both views.\r\n+        top_area_m2 = top_area_pixels / (PIXELS_PER_METER_HORIZONTAL ** 2)\r\n \r\n-    Args:\r\n-        top_view_data: Dictionary containing segmentation/processing results for the top view.\r\n-        front_view_data: Dictionary containing segmentation/processing results for the front view.\r\n+        # Estimate height from front view mask (e.g., using bounding box height)\r\n+        front_contours = front_seg_data.get('contours')\r\n+        estimated_height_m = 0.5  # Default height if contours are missing\r\n+        if front_contours:\r\n+            y_coords = np.vstack([cnt[:, :, 1] for cnt in front_contours])\r\n+            if y_coords.size > 0:\r\n+                min_y, max_y = np.min(y_coords), np.max(y_coords)\r\n+                height_pixels = max_y - min_y\r\n+                estimated_height_m = height_pixels / PIXELS_PER_METER_VERTICAL\r\n+            else:\r\n+                logger.warning(\"Front view contours found but empty, using default height.\")\r\n+        else:\r\n+            logger.warning(\"No front view contours found, using default height for volume estimation.\")\r\n \r\n-    Returns:\r\n-        The calculated volume (float) or None if calculation fails.\r\n-    \"\"\"\r\n-    logger.info(\"Calculating volume (Placeholder)...\")\r\n-    if not top_view_data or not front_view_data:\r\n-        logger.warning(\"Missing view data for volume calculation.\")\r\n-        return None\r\n+        # Basic volume estimation (e.g., base area * height - very approximate)\r\n+        # More sophisticated methods might involve integrating slices, using convex hulls on 3D points, etc.\r\n+        volume_m3 = top_area_m2 * estimated_height_m\r\n+        logger.info(f\"Placeholder volume calculated: {volume_m3:.3f} m³ (Area: {top_area_m2:.3f} m², Height: {estimated_height_m:.3f} m)\")\r\n \r\n-    # --- Placeholder Logic ---\r\n-    # Example: Use contour area from top view and assume a fixed height or estimate from front view\r\n-    top_mask = top_view_data.get('mask')\r\n-    if top_mask is None:\r\n-         logger.warning(\"Missing top view mask for volume calculation.\")\r\n-         return None\r\n+        # --- Placeholder 3D Points Generation (for visualization) ---\r\n+        # This is highly dependent on your setup and calculation method.\r\n+        # Example: Create a simple box based on estimated dimensions\r\n+        # Assumes origin is at one corner of the top-down bounding box\r\n+        if top_seg_data.get('contours'):\r\n+            x_coords = np.vstack([cnt[:, :, 0] for cnt in top_seg_data['contours']])\r\n+            y_coords_top = np.vstack([cnt[:, :, 1] for cnt in top_seg_data['contours']])\r\n+            if x_coords.size > 0 and y_coords_top.size > 0:\r\n+                min_x, max_x = np.min(x_coords), np.max(x_coords)\r\n+                min_y, max_y = np.min(y_coords_top), np.max(y_coords_top)\r\n+                width_pixels = max_x - min_x\r\n+                depth_pixels = max_y - min_y\r\n+                width_m = width_pixels / PIXELS_PER_METER_HORIZONTAL\r\n+                depth_m = depth_pixels / PIXELS_PER_METER_HORIZONTAL\r\n \r\n-    top_area_pixels = np.count_nonzero(top_mask)\r\n-    # This needs calibration: pixels to real-world area (e.g., pixels/m^2)\r\n-    pixels_per_square_meter = 10000 # Highly dependent on camera setup - MUST CALIBRATE\r\n-    top_area_m2 = top_area_pixels / pixels_per_square_meter\r\n+                # Create 8 corners of a bounding box\r\n+                points_3d = np.array([\r\n+                    [0, 0, 0], [width_m, 0, 0], [width_m, depth_m, 0], [0, depth_m, 0],  # Bottom face\r\n+                    [0, 0, estimated_height_m], [width_m, 0, estimated_height_m],        # Top face\r\n+                    [width_m, depth_m, estimated_height_m], [0, depth_m, estimated_height_m]\r\n+                ])\r\n+                logger.info(\"Generated placeholder 3D bounding box points for visualization.\")\r\n \r\n-    # Estimate height (e.g., from front view contours or fixed value)\r\n-    estimated_height_m = 0.5 # MUST BE DETERMINED from front view analysis or calibration\r\n+        # --- Calculate Density and Mass ---\r\n+        density_kg_m3 = get_density(material_type)\r\n+        if volume_m3 is not None:\r\n+            mass_kg = volume_m3 * density_kg_m3\r\n+            logger.info(f\"Placeholder mass calculated: {mass_kg:.2f} kg (Density: {density_kg_m3} kg/m³)\")\r\n+        else:\r\n+            mass_kg = None\r\n+            logger.warning(\"Volume calculation failed, cannot calculate mass.\")\r\n \r\n-    calculated_volume_m3 = top_area_m2 * estimated_height_m\r\n-    logger.info(f\"Placeholder volume calculated: {calculated_volume_m3:.2f} m³\")\r\n-    # --- End Placeholder ---\r\n+        # Return all results\r\n+        return {\r\n+            'volume': round(volume_m3, 3) if volume_m3 is not None else None,\r\n+            'mass': round(mass_kg, 2) if mass_kg is not None else None,\r\n+            'density': density_kg_m3,\r\n+            'points': points_3d  # This might be None if calculation fails or points aren't generated\r\n+        }\r\n \r\n-    return round(calculated_volume_m3, 2)\r\n-\r\n-# Add any other necessary helper functions for calculations below\r\n+    except Exception as e:\r\n+        logger.error(f\"Error during calculation: {e}\", exc_info=True)\r\n+        return None\r\n"
                },
                {
                    "date": 1745152118283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,129 +1,513 @@\n import numpy as np\r\n import logging\r\n import cv2\r\n from typing import Dict, Optional, Tuple, List, Union\r\n-from scipy.spatial import ConvexHull  # Example: If using convex hull for volume\r\n \r\n-logger = logging.getLogger(__name__)\r\n \r\n-# --- Placeholder Density Values (kg/m³) ---\r\n-# These should ideally come from user input or a configuration file\r\n-MATERIAL_DENSITIES = {\r\n-    \"Sand\": 1600,\r\n-    \"10mm Gravel\": 1500,\r\n-    \"20mm Gravel\": 1550,\r\n-    \"Default\": 1550  # Fallback\r\n-}\r\n+class Calculation:\r\n+    \"\"\"\r\n+    Enhanced calculation class for material volume and mass calculations.\r\n+    This class combines the functionality from the original Calculation class\r\n+    and key calculations from MaterialProperties.\r\n+    \"\"\"\r\n \r\n-def get_density(material_type: str = \"Default\") -> float:\r\n-    \"\"\"Gets the density for a given material type.\"\"\"\r\n-    density = MATERIAL_DENSITIES.get(material_type, MATERIAL_DENSITIES[\"Default\"])\r\n-    logger.info(f\"Using density for '{material_type}': {density} kg/m³\")\r\n-    return density\r\n+    # Define comprehensive material densities (kg/m³)\r\n+    MATERIAL_DENSITIES = {\r\n+        'Sand': {\r\n+            'Dry': 1600.0,\r\n+            'Wet': 1900.0,\r\n+            'Compacted': 2000.0\r\n+        },\r\n+        'Gravel': {\r\n+            'Loose': 1600.0,\r\n+            'Compacted': 1900.0,\r\n+            'Crushed': 1650.0,\r\n+            'Wet': 1800.0,\r\n+            'Dry': 1500.0\r\n+        },\r\n+        'Soil': {\r\n+            'Dry': 1300.0,\r\n+            'Wet': 1700.0,\r\n+            'Compacted': 1900.0\r\n+        },\r\n+        'Rock': {\r\n+            'Crushed': 1600.0,\r\n+            'Solid': 2700.0,\r\n+            'Wet': 2800.0\r\n+        },\r\n+        'Concrete': {\r\n+            'Regular': 2400.0,\r\n+            'Reinforced': 2500.0,\r\n+            'Fresh': 2350.0\r\n+        },\r\n+        'Other': 1800.0  # Default density\r\n+    }\r\n \r\n-def calculate_volume_mass_density(top_seg_data: dict, front_seg_data: dict, material_type: str = \"Default\"):\r\n+    # Define material specific gravity ranges\r\n+    MATERIAL_SPECIFIC_GRAVITY_RANGES = {\r\n+        \"Sand\": (2.65, 2.67),\r\n+        \"Gravel\": (2.5, 3.0),\r\n+        \"Concrete\": (2.3, 2.5),\r\n+        \"Soil\": (1.1, 1.3),\r\n+        \"Unknown\": (0, 0)\r\n+    }\r\n+\r\n+    def __init__(self):\r\n+        self.logger = logging.getLogger(__name__)\r\n+        self.logger.setLevel(logging.INFO)\r\n+        if not self.logger.handlers:\r\n+            handler = logging.StreamHandler()\r\n+            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\n+            handler.setFormatter(formatter)\r\n+            self.logger.addHandler(handler)\r\n+\r\n+        self.calibrated_densities = {}\r\n+        self.measurement_history = []\r\n+        self.MAX_HISTORY_SIZE = 10\r\n+\r\n+    def calculate_volume(self, volume_value: float, material_type: str = \"Sand\",\r\n+                         condition: str = None, material_density: Optional[float] = None,\r\n+                         known_mass: Optional[float] = None) -> Dict[str, float]:\r\n+        \"\"\"\r\n+        Volume and mass calculation with enhanced material property support\r\n+\r\n+        Args:\r\n+            volume_value: The volume value in m³\r\n+            material_type: Type of material (\"Sand\", \"Gravel\", \"Concrete\", \"Soil\", etc.)\r\n+            condition: Material condition (e.g., 'Dry', 'Wet', 'Compacted')\r\n+            material_density: Optional explicit density value in kg/m³\r\n+            known_mass: Optional known mass in kg for calibration\r\n+\r\n+        Returns:\r\n+            Dict with volume calculation results\r\n+        \"\"\"\r\n+        try:\r\n+            # Validate the calculated volume\r\n+            if volume_value <= 0 or np.isnan(volume_value) or np.isinf(volume_value):\r\n+                self.logger.error(f\"Invalid volume calculation result: {volume_value}\")\r\n+                return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n+                        \"condition\": condition, \"density\": 0.0,\r\n+                        \"error\": \"Invalid volume value\"}\r\n+\r\n+            # Get density using proper logic\r\n+            if material_density is not None:\r\n+                # Use explicitly provided density\r\n+                self.logger.info(f\"Using explicitly provided density: {material_density} kg/m³\")\r\n+            elif known_mass is not None:\r\n+                # Calibrate density using the known mass\r\n+                material_density = self.calibrate_density(known_mass, volume_value, material_type)\r\n+                self.logger.info(f\"Using calibrated density: {material_density} kg/m³\")\r\n+            else:\r\n+                # Use enhanced get_material_density method\r\n+                material_density = self.get_material_density(material_type, condition)\r\n+                self.logger.info(f\"Using material density for {material_type} ({condition}): {material_density} kg/m³\")\r\n+\r\n+            # Calculate mass in metric tons\r\n+            mass = self.calculate_mass(volume_value, material_type, condition, material_density)\r\n+\r\n+            # Store result in history for consistency checking\r\n+            result = {\r\n+                \"total\": volume_value,\r\n+                \"mass\": mass,\r\n+                \"material_type\": material_type,\r\n+                \"condition\": condition,\r\n+                \"density\": material_density,\r\n+                \"timestamp\": None,  # Can be filled with actual timestamp if needed\r\n+                \"error\": None\r\n+            }\r\n+\r\n+            # Add to history and maintain maximum size\r\n+            self.measurement_history.append(result)\r\n+            if len(self.measurement_history) > self.MAX_HISTORY_SIZE:\r\n+                self.measurement_history.pop(0)\r\n+\r\n+            # Only perform consistency check if we have enough history\r\n+            if len(self.measurement_history) >= 3:\r\n+                result = self._check_measurement_consistency(result)\r\n+\r\n+            self.logger.info(f\"Final volume calculation: {volume_value:.2f} m³, {mass:.2f} metric tons\")\r\n+            return result\r\n+\r\n+        except Exception as e:\r\n+            self.logger.error(f\"Volume calculation failed: {str(e)}\")\r\n+            return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n+                    \"condition\": condition, \"density\": 0.0,\r\n+                    \"error\": f\"Exception: {str(e)}\"}\r\n+\r\n+    def get_material_density(self, material_type: str, condition: str = None) -> float:\r\n+        \"\"\"\r\n+        Get the density of a material based on its type and condition.\r\n+\r\n+        Args:\r\n+            material_type (str): Type of material (e.g., 'Sand', 'Gravel')\r\n+            condition (str, optional): Condition of material (e.g., 'Dry', 'Wet', 'Compacted')\r\n+\r\n+        Returns:\r\n+            float: Material density in kg/m³\r\n+        \"\"\"\r\n+        try:\r\n+            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n+\r\n+            # If material type not found, return default density\r\n+            if material_type not in self.MATERIAL_DENSITIES:\r\n+                self.logger.warning(f\"Unknown material type: {material_type}, using default density\")\r\n+                return self.MATERIAL_DENSITIES['Other']\r\n+\r\n+            material_data = self.MATERIAL_DENSITIES[material_type]\r\n+\r\n+            # If no condition specified or invalid condition, return average density\r\n+            if not condition or not isinstance(material_data, dict):\r\n+                return sum(material_data.values()) / len(material_data)\r\n+\r\n+            condition = condition.strip().capitalize() if condition else None\r\n+            if condition in material_data:\r\n+                density = material_data[condition]\r\n+            else:\r\n+                # Return average if condition not found\r\n+                self.logger.warning(f\"Unknown condition: {condition} for {material_type}, using average density\")\r\n+                density = sum(material_data.values()) / len(material_data)\r\n+\r\n+            # Calculate specific gravity\r\n+            specific_gravity = density / 1000  # Convert kg/m³ to specific gravity (water density = 1000 kg/m³)\r\n+\r\n+            # Validate specific gravity against known ranges\r\n+            if material_type in self.MATERIAL_SPECIFIC_GRAVITY_RANGES:\r\n+                min_sg, max_sg = self.MATERIAL_SPECIFIC_GRAVITY_RANGES[material_type]\r\n+                if not (min_sg <= specific_gravity <= max_sg):\r\n+                    self.logger.warning(\r\n+                        f\"Specific gravity {specific_gravity} for {material_type} is outside expected range ({min_sg}-{max_sg})\")\r\n+\r\n+            return density\r\n+\r\n+        except Exception as e:\r\n+            self.logger.error(f\"Error getting material density: {str(e)}\")\r\n+            return self.MATERIAL_DENSITIES['Other']\r\n+\r\n+    def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n+                       density: Optional[float] = None) -> float:\r\n+        \"\"\"\r\n+        Calculate mass based on volume and material type.\r\n+\r\n+        Args:\r\n+            volume (float): Volume in cubic meters\r\n+            material_type (str): Type of material\r\n+            condition (str, optional): Condition of material\r\n+            density (float, optional): Override density if provided\r\n+\r\n+        Returns:\r\n+            float: Mass in metric tons\r\n+        \"\"\"\r\n+        if density is None:\r\n+            density = self.get_material_density(material_type, condition)\r\n+        return volume * density / 1000.0  # Convert to metric tons\r\n+\r\n+    def calibrate_density(self, known_mass: float, measured_volume: float, material_type: str = \"Sand\") -> float:\r\n+        \"\"\"\r\n+        Simple density calibration based on known mass and measured volume\r\n+\r\n+        Args:\r\n+            known_mass (float): Known mass in kg.\r\n+            measured_volume (float): Measured volume in m³.\r\n+            material_type (str): Type of material being calibrated.\r\n+        Returns:\r\n+            float: Calibrated density in kg/m³.\r\n+        \"\"\"\r\n+        if measured_volume <= 0:\r\n+            self.logger.error(\"Cannot calibrate with zero or negative volume\")\r\n+            return self.get_material_density(material_type)\r\n+\r\n+        # Use the actual measured mass/volume for calibration\r\n+        calibrated_density = known_mass / measured_volume\r\n+\r\n+        # Store the calibrated density\r\n+        self.calibrated_densities[material_type] = calibrated_density\r\n+\r\n+        self.logger.info(f\"Calibration for {material_type}:\")\r\n+        self.logger.info(f\"- Calibrated density: {calibrated_density:.2f} kg/m³\")\r\n+\r\n+        return calibrated_density\r\n+\r\n+    def _check_measurement_consistency(self, current_result: Dict[str, float]) -> Dict[str, float]:\r\n+        \"\"\"Check if current measurement is consistent with recent history\"\"\"\r\n+        # Extract recent volumes and masses\r\n+        recent_volumes = [r[\"total\"] for r in self.measurement_history[-3:] if \"total\" in r]\r\n+        recent_masses = [r[\"mass\"] for r in self.measurement_history[-3:] if \"mass\" in r and r[\"mass\"] is not None]\r\n+\r\n+        if not recent_volumes or not recent_masses:\r\n+            return current_result\r\n+\r\n+        # Calculate mean and standard deviation\r\n+        mean_volume = np.mean(recent_volumes)\r\n+        std_volume = np.std(recent_volumes)\r\n+        mean_mass = np.mean(recent_masses)\r\n+        std_mass = np.std(recent_masses)\r\n+\r\n+        # Check if current measurement is within reasonable bounds (3 standard deviations)\r\n+        if std_volume > 0 and abs(current_result[\"total\"] - mean_volume) > 3 * std_volume:\r\n+            self.logger.warning(\r\n+                f\"Volume measurement ({current_result['total']:.2f}) deviates significantly from recent average ({mean_volume:.2f}), std: {std_volume:.2f}\")\r\n+            # Apply smoothing\r\n+            current_result[\"total\"] = 0.7 * current_result[\"total\"] + 0.3 * mean_volume\r\n+            self.logger.info(f\"Adjusted volume to {current_result['total']:.2f}\")\r\n+\r\n+        if std_mass > 0 and abs(current_result[\"mass\"] - mean_mass) > 3 * std_mass:\r\n+            self.logger.warning(\r\n+                f\"Mass measurement ({current_result['mass']:.2f}) deviates significantly from recent average ({mean_mass:.2f}), std: {std_mass:.2f}\")\r\n+            # Apply smoothing\r\n+            current_result[\"mass\"] = 0.7 * current_result[\"mass\"] + 0.3 * mean_mass\r\n+            self.logger.info(f\"Adjusted mass to {current_result['mass']:.2f}\")\r\n+\r\n+        return current_result\r\n+\r\n+    def validate_material_properties(self, material_type: str, density: Optional[float] = None) -> Dict:\r\n+        \"\"\"\r\n+        Validate material properties and provide recommendations.\r\n+\r\n+        Args:\r\n+            material_type (str): Type of material\r\n+            density (float, optional): User-provided density\r\n+\r\n+        Returns:\r\n+            Dict: Validation results and recommendations\r\n+        \"\"\"\r\n+        result = {\r\n+            'valid': True,\r\n+            'message': '',\r\n+            'recommended_density': None,\r\n+            'density_range': None\r\n+        }\r\n+\r\n+        try:\r\n+            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n+            if material_type not in self.MATERIAL_DENSITIES:\r\n+                result['valid'] = False\r\n+                result['message'] = f\"Unknown material type: {material_type}\"\r\n+                return result\r\n+\r\n+            material_data = self.MATERIAL_DENSITIES[material_type]\r\n+            densities = list(material_data.values())\r\n+            min_density = min(densities)\r\n+            max_density = max(densities)\r\n+            avg_density = sum(densities) / len(densities)\r\n+\r\n+            result['density_range'] = (min_density, max_density)\r\n+            result['recommended_density'] = avg_density\r\n+\r\n+            if density is not None:\r\n+                if density < min_density * 0.5 or density > max_density * 1.5:\r\n+                    result['valid'] = False\r\n+                    result[\r\n+                        'message'] = f\"Density {density} kg/m³ is outside expected range ({min_density}-{max_density} kg/m³)\"\r\n+                elif density < min_density or density > max_density:\r\n+                    result['message'] = f\"Warning: Density {density} kg/m³ is unusual for {material_type}\"\r\n+\r\n+        except Exception as e:\r\n+            result['valid'] = False\r\n+            result['message'] = f\"Error validating properties: {str(e)}\"\r\n+\r\n+        return result\r\n+\r\n+    def get_material_conditions(self, material_type: str) -> list:\r\n+        \"\"\"\r\n+        Get available conditions for a material type.\r\n+\r\n+        Args:\r\n+            material_type (str): Type of material\r\n+\r\n+        Returns:\r\n+            list: Available conditions for the material\r\n+        \"\"\"\r\n+        try:\r\n+            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n+            if material_type in self.MATERIAL_DENSITIES:\r\n+                return list(self.MATERIAL_DENSITIES[material_type].keys())\r\n+            return []\r\n+        except Exception:\r\n+            return []\r\n+\r\n+    def get_available_materials(self) -> list:\r\n+        \"\"\"\r\n+        Get list of available material types.\r\n+\r\n+        Returns:\r\n+            list: Available material types\r\n+        \"\"\"\r\n+        return list(self.MATERIAL_DENSITIES.keys())\r\n+\r\n+    def adjust_sand_density(self, base_density: float,\r\n+                            moisture_content: float = 0.0,\r\n+                            compaction_level: str = \"loose\",\r\n+                            sand_type: str = \"standard\") -> float:\r\n+        \"\"\"\r\n+        Adjust sand density based on various factors.\r\n+\r\n+        Args:\r\n+            base_density: Base density in kg/m³\r\n+            moisture_content: Moisture percentage (0-100)\r\n+            compaction_level: \"loose\", \"medium\", or \"dense\"\r\n+            sand_type: Type of sand (\"fine\", \"coarse\", \"standard\")\r\n+\r\n+        Returns:\r\n+            Adjusted density in kg/m³\r\n+        \"\"\"\r\n+        # Moisture adjustment factor\r\n+        moisture_factor = 1 + (moisture_content / 100)\r\n+\r\n+        # Compaction adjustment\r\n+        compaction_factors = {\r\n+            \"loose\": 0.85,\r\n+            \"medium\": 1.0,\r\n+            \"dense\": 1.15\r\n+        }\r\n+        compaction_factor = compaction_factors.get(compaction_level, 1.0)\r\n+\r\n+        # Sand type adjustment\r\n+        sand_type_factors = {\r\n+            \"fine\": 0.95,\r\n+            \"standard\": 1.0,\r\n+            \"coarse\": 1.05\r\n+        }\r\n+        type_factor = sand_type_factors.get(sand_type, 1.0)\r\n+\r\n+        # Calculate adjusted density\r\n+        adjusted_density = base_density * moisture_factor * compaction_factor * type_factor\r\n+\r\n+        self.logger.info(f\"Adjusted sand density: {adjusted_density:.2f} kg/m³ \"\r\n+                         f\"(moisture: {moisture_content}%, compaction: {compaction_level}, type: {sand_type})\")\r\n+\r\n+        return adjusted_density\r\n+\r\n+    def calculate_conical_pile_volume(self, area: float, height: float) -> float:\r\n+        \"\"\"\r\n+        Calculate volume of a conical pile based on base area and height.\r\n+        Conical piles typically have 1/3 the volume of a cylinder with the same base and height.\r\n+\r\n+        Args:\r\n+            area: Base area in m²\r\n+            height: Height in m\r\n+\r\n+        Returns:\r\n+            Volume in m³\r\n+        \"\"\"\r\n+        cone_factor = 1 / 3\r\n+        volume = area * height * cone_factor\r\n+        return volume\r\n+\r\n+    def validate_results(self, calculated_result: Dict[str, float],\r\n+                         ground_truth: Dict[str, float]) -> Dict[str, float]:\r\n+        \"\"\"Calculate accuracy metrics for volume and mass.\"\"\"\r\n+        metrics = {}\r\n+\r\n+        # Validate volume\r\n+        if 'total' in calculated_result and 'volume' in ground_truth:\r\n+            vol_abs_error = abs(calculated_result['total'] - ground_truth['volume'])\r\n+            vol_rel_error = vol_abs_error / ground_truth['volume'] * 100 if ground_truth['volume'] > 0 else float('inf')\r\n+\r\n+            metrics.update({\r\n+                'volume_absolute_error': vol_abs_error,\r\n+                'volume_relative_error': vol_rel_error,\r\n+                'volume_rmse': np.sqrt(vol_abs_error ** 2)\r\n+            })\r\n+\r\n+        # Validate mass if density is provided\r\n+        if 'mass' in calculated_result and 'density' in ground_truth:\r\n+            true_mass = ground_truth['volume'] * ground_truth['density'] / 1000.0\r\n+            mass_abs_error = abs(calculated_result['mass'] - true_mass)\r\n+            mass_rel_error = mass_abs_error / true_mass * 100 if true_mass > 0 else float('inf')\r\n+\r\n+            metrics.update({\r\n+                'mass_absolute_error': mass_abs_error,\r\n+                'mass_relative_error': mass_rel_error,\r\n+                'mass_rmse': np.sqrt(mass_abs_error ** 2)\r\n+            })\r\n+\r\n+        return metrics\r\n+\r\n+\r\n+# Example usage\r\n+if __name__ == \"__main__\":\r\n+    # Configure logging\r\n+    logging.basicConfig(\r\n+        level=logging.INFO,\r\n+        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\r\n+    )\r\n+\r\n+logger = logging.getLogger(__name__)\r\n+\r\n+def calculate_damage(segmentation_result):\r\n     \"\"\"\r\n-    Placeholder function to calculate volume, mass, and density.\r\n-    Replace with your actual calculation logic using data from both views.\r\n+    Placeholder function to calculate damage metrics.\r\n+    Replace with your actual damage calculation logic.\r\n \r\n     Args:\r\n-        top_seg_data: Dictionary containing segmentation results for the top view (e.g., 'mask', 'contours').\r\n-        front_seg_data: Dictionary containing segmentation results for the front view (e.g., 'mask', 'contours').\r\n-        material_type: String indicating the material (e.g., \"Sand\", \"10mm Gravel\").\r\n+        segmentation_result: Dictionary containing segmentation data (e.g., mask, contours).\r\n \r\n     Returns:\r\n-        A dictionary containing {'volume': float, 'mass': float, 'density': float, 'points': np.ndarray | None}\r\n-        Returns None if critical calculation fails.\r\n+        A dictionary with damage metrics (e.g., {'crack_area_percentage': 5.2})\r\n+        or None if calculation fails.\r\n     \"\"\"\r\n-    logger.info(\"Calculating volume, mass, density (Placeholder)...\")\r\n-    if not top_seg_data or not front_seg_data or 'mask' not in top_seg_data or 'mask' not in front_seg_data:\r\n-        logger.warning(\"Missing or invalid segmentation data for calculation.\")\r\n+    logger.info(\"Calculating damage (Placeholder)...\")\r\n+    if not segmentation_result or 'mask' not in segmentation_result:\r\n+        logger.warning(\"Invalid segmentation result for damage calculation.\")\r\n         return None\r\n \r\n-    volume_m3 = None\r\n-    mass_kg = None\r\n-    points_3d = None  # Placeholder for 3D points for visualization\r\n+    # --- Placeholder Logic ---\r\n+    # Example: Calculate percentage of mask area relative to total image area\r\n+    mask = segmentation_result['mask']\r\n+    if mask is None or mask.size == 0:\r\n+         logger.warning(\"Mask is empty in segmentation result.\")\r\n+         return {'damage_description': 'No mask found'}\r\n \r\n-    try:\r\n-        # --- Placeholder Volume Logic ---\r\n-        top_mask = top_seg_data['mask']\r\n-        front_mask = front_seg_data['mask']\r\n+    total_pixels = mask.size\r\n+    damage_pixels = np.count_nonzero(mask)\r\n+    damage_percentage = (damage_pixels / total_pixels) * 100 if total_pixels > 0 else 0\r\n \r\n-        if top_mask is None or front_mask is None:\r\n-            logger.warning(\"Missing mask in segmentation data.\")\r\n-            return None\r\n+    logger.info(f\"Placeholder damage calculated: {damage_percentage:.2f}% area\")\r\n+    # --- End Placeholder ---\r\n \r\n-        # Example: Estimate volume using top area and estimated height from front view\r\n-        top_area_pixels = np.count_nonzero(top_mask)\r\n+    # Return results in a dictionary\r\n+    return {\r\n+        'damage_area_percentage': round(damage_percentage, 2),\r\n+        'description': 'Calculated based on segmented mask area (Placeholder)'\r\n+    }\r\n \r\n-        # --- CRITICAL: Calibration Needed ---\r\n-        # You MUST determine the relationship between pixels and real-world units (e.g., meters)\r\n-        # This depends entirely on your camera setup (distance, lens, etc.)\r\n-        PIXELS_PER_METER_HORIZONTAL = 500  # Example value - MUST BE CALIBRATED\r\n-        PIXELS_PER_METER_VERTICAL = 500    # Example value - MUST BE CALIBRATED\r\n-        # --- End Calibration ---\r\n \r\n-        top_area_m2 = top_area_pixels / (PIXELS_PER_METER_HORIZONTAL ** 2)\r\n+def calculate_volume(top_view_data, front_view_data):\r\n+    \"\"\"\r\n+    Placeholder function to calculate volume based on processed view data.\r\n+    Replace with your actual volume calculation logic using data from both views.\r\n \r\n-        # Estimate height from front view mask (e.g., using bounding box height)\r\n-        front_contours = front_seg_data.get('contours')\r\n-        estimated_height_m = 0.5  # Default height if contours are missing\r\n-        if front_contours:\r\n-            y_coords = np.vstack([cnt[:, :, 1] for cnt in front_contours])\r\n-            if y_coords.size > 0:\r\n-                min_y, max_y = np.min(y_coords), np.max(y_coords)\r\n-                height_pixels = max_y - min_y\r\n-                estimated_height_m = height_pixels / PIXELS_PER_METER_VERTICAL\r\n-            else:\r\n-                logger.warning(\"Front view contours found but empty, using default height.\")\r\n-        else:\r\n-            logger.warning(\"No front view contours found, using default height for volume estimation.\")\r\n+    Args:\r\n+        top_view_data: Dictionary containing segmentation/processing results for the top view.\r\n+        front_view_data: Dictionary containing segmentation/processing results for the front view.\r\n \r\n-        # Basic volume estimation (e.g., base area * height - very approximate)\r\n-        # More sophisticated methods might involve integrating slices, using convex hulls on 3D points, etc.\r\n-        volume_m3 = top_area_m2 * estimated_height_m\r\n-        logger.info(f\"Placeholder volume calculated: {volume_m3:.3f} m³ (Area: {top_area_m2:.3f} m², Height: {estimated_height_m:.3f} m)\")\r\n+    Returns:\r\n+        The calculated volume (float) or None if calculation fails.\r\n+    \"\"\"\r\n+    logger.info(\"Calculating volume (Placeholder)...\")\r\n+    if not top_view_data or not front_view_data:\r\n+        logger.warning(\"Missing view data for volume calculation.\")\r\n+        return None\r\n \r\n-        # --- Placeholder 3D Points Generation (for visualization) ---\r\n-        # This is highly dependent on your setup and calculation method.\r\n-        # Example: Create a simple box based on estimated dimensions\r\n-        # Assumes origin is at one corner of the top-down bounding box\r\n-        if top_seg_data.get('contours'):\r\n-            x_coords = np.vstack([cnt[:, :, 0] for cnt in top_seg_data['contours']])\r\n-            y_coords_top = np.vstack([cnt[:, :, 1] for cnt in top_seg_data['contours']])\r\n-            if x_coords.size > 0 and y_coords_top.size > 0:\r\n-                min_x, max_x = np.min(x_coords), np.max(x_coords)\r\n-                min_y, max_y = np.min(y_coords_top), np.max(y_coords_top)\r\n-                width_pixels = max_x - min_x\r\n-                depth_pixels = max_y - min_y\r\n-                width_m = width_pixels / PIXELS_PER_METER_HORIZONTAL\r\n-                depth_m = depth_pixels / PIXELS_PER_METER_HORIZONTAL\r\n+    # --- Placeholder Logic ---\r\n+    # Example: Use contour area from top view and assume a fixed height or estimate from front view\r\n+    top_mask = top_view_data.get('mask')\r\n+    if top_mask is None:\r\n+         logger.warning(\"Missing top view mask for volume calculation.\")\r\n+         return None\r\n \r\n-                # Create 8 corners of a bounding box\r\n-                points_3d = np.array([\r\n-                    [0, 0, 0], [width_m, 0, 0], [width_m, depth_m, 0], [0, depth_m, 0],  # Bottom face\r\n-                    [0, 0, estimated_height_m], [width_m, 0, estimated_height_m],        # Top face\r\n-                    [width_m, depth_m, estimated_height_m], [0, depth_m, estimated_height_m]\r\n-                ])\r\n-                logger.info(\"Generated placeholder 3D bounding box points for visualization.\")\r\n+    top_area_pixels = np.count_nonzero(top_mask)\r\n+    # This needs calibration: pixels to real-world area (e.g., pixels/m^2)\r\n+    pixels_per_square_meter = 10000 # Highly dependent on camera setup - MUST CALIBRATE\r\n+    top_area_m2 = top_area_pixels / pixels_per_square_meter\r\n \r\n-        # --- Calculate Density and Mass ---\r\n-        density_kg_m3 = get_density(material_type)\r\n-        if volume_m3 is not None:\r\n-            mass_kg = volume_m3 * density_kg_m3\r\n-            logger.info(f\"Placeholder mass calculated: {mass_kg:.2f} kg (Density: {density_kg_m3} kg/m³)\")\r\n-        else:\r\n-            mass_kg = None\r\n-            logger.warning(\"Volume calculation failed, cannot calculate mass.\")\r\n+    # Estimate height (e.g., from front view contours or fixed value)\r\n+    estimated_height_m = 0.5 # MUST BE DETERMINED from front view analysis or calibration\r\n \r\n-        # Return all results\r\n-        return {\r\n-            'volume': round(volume_m3, 3) if volume_m3 is not None else None,\r\n-            'mass': round(mass_kg, 2) if mass_kg is not None else None,\r\n-            'density': density_kg_m3,\r\n-            'points': points_3d  # This might be None if calculation fails or points aren't generated\r\n-        }\r\n+    calculated_volume_m3 = top_area_m2 * estimated_height_m\r\n+    logger.info(f\"Placeholder volume calculated: {calculated_volume_m3:.2f} m³\")\r\n+    # --- End Placeholder ---\r\n \r\n-    except Exception as e:\r\n-        logger.error(f\"Error during calculation: {e}\", exc_info=True)\r\n-        return None\r\n+    return round(calculated_volume_m3, 2)\r\n+\r\n+# Add any other necessary helper functions for calculations below\r\n"
                },
                {
                    "date": 1745160955401,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,9 +156,11 @@\n             material_data = self.MATERIAL_DENSITIES[material_type]\r\n \r\n             # If no condition specified or invalid condition, return average density\r\n             if not condition or not isinstance(material_data, dict):\r\n-                return sum(material_data.values()) / len(material_data)\r\n+                # If material_data is NOT a dict (e.g., for 'Other': 1800.0),\r\n+                # material_data.values() will cause a TypeError because float is not iterable\r\n+                return material_data if isinstance(material_data, float) else sum(material_data.values()) / len(material_data)\r\n \r\n             condition = condition.strip().capitalize() if condition else None\r\n             if condition in material_data:\r\n                 density = material_data[condition]\r\n"
                },
                {
                    "date": 1745160995866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,515 +1,207 @@\n import numpy as np\r\n import logging\r\n import cv2\r\n from typing import Dict, Optional, Tuple, List, Union\r\n+from scipy.spatial import ConvexHull  # Keep if used later\r\n \r\n \r\n class Calculation:\r\n     \"\"\"\r\n     Enhanced calculation class for material volume and mass calculations.\r\n-    This class combines the functionality from the original Calculation class\r\n-    and key calculations from MaterialProperties.\r\n     \"\"\"\r\n \r\n     # Define comprehensive material densities (kg/m³)\r\n     MATERIAL_DENSITIES = {\r\n         'Sand': {\r\n-            'Dry': 1600.0,\r\n-            'Wet': 1900.0,\r\n-            'Compacted': 2000.0\r\n+            'Dry': 1600.0, 'Wet': 1900.0, 'Compacted': 2000.0\r\n         },\r\n         'Gravel': {\r\n-            'Loose': 1600.0,\r\n-            'Compacted': 1900.0,\r\n-            'Crushed': 1650.0,\r\n-            'Wet': 1800.0,\r\n-            'Dry': 1500.0\r\n+            'Loose': 1600.0, 'Compacted': 1900.0, 'Crushed': 1650.0, 'Wet': 1800.0, 'Dry': 1500.0\r\n         },\r\n         'Soil': {\r\n-            'Dry': 1300.0,\r\n-            'Wet': 1700.0,\r\n-            'Compacted': 1900.0\r\n+            'Dry': 1300.0, 'Wet': 1700.0, 'Compacted': 1900.0\r\n         },\r\n         'Rock': {\r\n-            'Crushed': 1600.0,\r\n-            'Solid': 2700.0,\r\n-            'Wet': 2800.0\r\n+            'Crushed': 1600.0, 'Solid': 2700.0, 'Wet': 2800.0\r\n         },\r\n         'Concrete': {\r\n-            'Regular': 2400.0,\r\n-            'Reinforced': 2500.0,\r\n-            'Fresh': 2350.0\r\n+            'Regular': 2400.0, 'Reinforced': 2500.0, 'Fresh': 2350.0\r\n         },\r\n-        'Other': 1800.0  # Default density\r\n+        'Other': 1800.0  # Default density (single value, not a dict)\r\n     }\r\n \r\n     # Define material specific gravity ranges\r\n     MATERIAL_SPECIFIC_GRAVITY_RANGES = {\r\n-        \"Sand\": (2.65, 2.67),\r\n-        \"Gravel\": (2.5, 3.0),\r\n-        \"Concrete\": (2.3, 2.5),\r\n-        \"Soil\": (1.1, 1.3),\r\n-        \"Unknown\": (0, 0)\r\n+        \"Sand\": (2.65, 2.67), \"Gravel\": (2.5, 3.0), \"Concrete\": (2.3, 2.5),\r\n+        \"Soil\": (1.1, 1.3), \"Unknown\": (0, 0)\r\n     }\r\n \r\n+    # --- CRITICAL: Calibration Needed ---\r\n+    # These MUST be calibrated based on your specific camera setup\r\n+    PIXELS_PER_METER_HORIZONTAL = 500  # Example value\r\n+    PIXELS_PER_METER_VERTICAL = 500    # Example value\r\n+    # --- End Calibration ---\r\n+\r\n     def __init__(self):\r\n         self.logger = logging.getLogger(__name__)\r\n-        self.logger.setLevel(logging.INFO)\r\n-        if not self.logger.handlers:\r\n-            handler = logging.StreamHandler()\r\n-            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\n-            handler.setFormatter(formatter)\r\n-            self.logger.addHandler(handler)\r\n+        # Ensure logger is configured (e.g., in App/__init__.py)\r\n+        # Basic config if not already set elsewhere:\r\n+        if not self.logger.hasHandlers():\r\n+            logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\n \r\n         self.calibrated_densities = {}\r\n         self.measurement_history = []\r\n         self.MAX_HISTORY_SIZE = 10\r\n \r\n-    def calculate_volume(self, volume_value: float, material_type: str = \"Sand\",\r\n-                         condition: str = None, material_density: Optional[float] = None,\r\n-                         known_mass: Optional[float] = None) -> Dict[str, float]:\r\n+    # --- NEW METHOD to integrate with segmentation ---\r\n+    def calculate_from_segmentation(self, top_seg_data: dict, front_seg_data: dict,\r\n+                                    material_type: str = \"Gravel\",  # Default to Gravel based on image\r\n+                                    condition: str = \"Loose\") -> Optional[Dict[str, Union[float, np.ndarray]]]:\r\n         \"\"\"\r\n-        Volume and mass calculation with enhanced material property support\r\n+        Calculates volume, mass, density from segmentation data.\r\n \r\n         Args:\r\n-            volume_value: The volume value in m³\r\n-            material_type: Type of material (\"Sand\", \"Gravel\", \"Concrete\", \"Soil\", etc.)\r\n-            condition: Material condition (e.g., 'Dry', 'Wet', 'Compacted')\r\n-            material_density: Optional explicit density value in kg/m³\r\n-            known_mass: Optional known mass in kg for calibration\r\n+            top_seg_data: Dictionary from perform_segmentation (top view).\r\n+            front_seg_data: Dictionary from perform_segmentation (front view).\r\n+            material_type: Type of material.\r\n+            condition: Condition of material.\r\n \r\n         Returns:\r\n-            Dict with volume calculation results\r\n+            Dictionary with 'volume', 'mass', 'density', 'points' (for viz), or None on failure.\r\n         \"\"\"\r\n+        self.logger.info(f\"Starting calculation from segmentation for material: {material_type} ({condition})\")\r\n+        if not top_seg_data or not front_seg_data or 'mask' not in top_seg_data or 'mask' not in front_seg_data:\r\n+            self.logger.error(\"Missing or invalid segmentation data for calculation.\")\r\n+            return None\r\n+\r\n+        volume_m3 = None\r\n+        points_3d = None\r\n+\r\n         try:\r\n-            # Validate the calculated volume\r\n-            if volume_value <= 0 or np.isnan(volume_value) or np.isinf(volume_value):\r\n-                self.logger.error(f\"Invalid volume calculation result: {volume_value}\")\r\n-                return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n-                        \"condition\": condition, \"density\": 0.0,\r\n-                        \"error\": \"Invalid volume value\"}\r\n+            # --- Estimate Volume (Example Logic - NEEDS REFINEMENT/VALIDATION) ---\r\n+            top_mask = top_seg_data['mask']\r\n+            front_mask = front_seg_data['mask']  # Use front mask for height estimation\r\n \r\n-            # Get density using proper logic\r\n-            if material_density is not None:\r\n-                # Use explicitly provided density\r\n-                self.logger.info(f\"Using explicitly provided density: {material_density} kg/m³\")\r\n-            elif known_mass is not None:\r\n-                # Calibrate density using the known mass\r\n-                material_density = self.calibrate_density(known_mass, volume_value, material_type)\r\n-                self.logger.info(f\"Using calibrated density: {material_density} kg/m³\")\r\n+            if top_mask is None or front_mask is None:\r\n+                self.logger.error(\"Missing mask in segmentation data.\")\r\n+                return None\r\n+\r\n+            top_area_pixels = np.count_nonzero(top_mask)\r\n+            if top_area_pixels == 0:\r\n+                self.logger.warning(\"Top view mask is empty, volume will be zero.\")\r\n+                return {'volume': 0.0, 'mass': 0.0, 'density': self.get_material_density(material_type, condition), 'points': None}\r\n+\r\n+            top_area_m2 = top_area_pixels / (self.PIXELS_PER_METER_HORIZONTAL ** 2)\r\n+\r\n+            # Estimate height from front view mask's bounding box\r\n+            front_contours = front_seg_data.get('contours')\r\n+            estimated_height_m = 0.1  # Minimum default height\r\n+            if front_contours:\r\n+                all_points = np.vstack([cnt for cnt in front_contours])\r\n+                if all_points.size > 0:\r\n+                    _, y, _, h = cv2.boundingRect(all_points)  # Use bounding rect height\r\n+                    height_pixels = h\r\n+                    estimated_height_m = max(estimated_height_m, height_pixels / self.PIXELS_PER_METER_VERTICAL)  # Ensure non-zero height\r\n+                else:\r\n+                    self.logger.warning(\"Front view contours found but empty, using default height.\")\r\n             else:\r\n-                # Use enhanced get_material_density method\r\n-                material_density = self.get_material_density(material_type, condition)\r\n-                self.logger.info(f\"Using material density for {material_type} ({condition}): {material_density} kg/m³\")\r\n+                self.logger.warning(\"No front view contours found, using default height for volume estimation.\")\r\n \r\n-            # Calculate mass in metric tons\r\n-            mass = self.calculate_mass(volume_value, material_type, condition, material_density)\r\n+            # Basic volume estimation (base area * height) - Very approximate\r\n+            volume_m3 = top_area_m2 * estimated_height_m\r\n+            self.logger.info(f\"Estimated Volume: {volume_m3:.4f} m³ (Area: {top_area_m2:.4f} m², Height: {estimated_height_m:.3f} m)\")\r\n \r\n-            # Store result in history for consistency checking\r\n-            result = {\r\n-                \"total\": volume_value,\r\n-                \"mass\": mass,\r\n-                \"material_type\": material_type,\r\n-                \"condition\": condition,\r\n-                \"density\": material_density,\r\n-                \"timestamp\": None,  # Can be filled with actual timestamp if needed\r\n-                \"error\": None\r\n+            # --- Generate 3D Points (Example: Bounding Box) ---\r\n+            if top_seg_data.get('contours'):\r\n+                all_top_points = np.vstack([cnt for cnt in top_seg_data['contours']])\r\n+                if all_top_points.size > 0:\r\n+                    x, y, w, h = cv2.boundingRect(all_top_points)\r\n+                    width_m = w / self.PIXELS_PER_METER_HORIZONTAL\r\n+                    depth_m = h / self.PIXELS_PER_METER_HORIZONTAL  # Use horizontal scale for top-down depth\r\n+\r\n+                    points_3d = np.array([\r\n+                        [0, 0, 0], [width_m, 0, 0], [width_m, depth_m, 0], [0, depth_m, 0],  # Bottom\r\n+                        [0, 0, estimated_height_m], [width_m, 0, estimated_height_m],        # Top\r\n+                        [width_m, depth_m, estimated_height_m], [0, depth_m, estimated_height_m]\r\n+                    ])\r\n+                    self.logger.info(\"Generated placeholder 3D bounding box points.\")\r\n+\r\n+            # --- Use class methods for density and mass ---\r\n+            density_kg_m3 = self.get_material_density(material_type, condition)\r\n+            mass_kg = self.calculate_mass(volume_m3, material_type, condition, density_kg_m3)  # Pass density directly\r\n+\r\n+            # Store result in history (using the structure from calculate_volume)\r\n+            result_for_history = {\r\n+                \"total\": volume_m3, \"mass\": mass_kg / 1000.0,  # Convert mass to tonnes for history consistency? Check calculate_mass return unit\r\n+                \"material_type\": material_type, \"condition\": condition, \"density\": density_kg_m3,\r\n+                \"timestamp\": None, \"error\": None\r\n             }\r\n-\r\n-            # Add to history and maintain maximum size\r\n-            self.measurement_history.append(result)\r\n+            self.measurement_history.append(result_for_history)\r\n             if len(self.measurement_history) > self.MAX_HISTORY_SIZE:\r\n                 self.measurement_history.pop(0)\r\n \r\n-            # Only perform consistency check if we have enough history\r\n-            if len(self.measurement_history) >= 3:\r\n-                result = self._check_measurement_consistency(result)\r\n+            # Return results needed by the route\r\n+            return {\r\n+                'volume': round(volume_m3, 4),\r\n+                'mass': round(mass_kg, 2),  # Return mass in KG\r\n+                'density': round(density_kg_m3, 2),\r\n+                'points': points_3d\r\n+            }\r\n \r\n-            self.logger.info(f\"Final volume calculation: {volume_value:.2f} m³, {mass:.2f} metric tons\")\r\n-            return result\r\n-\r\n         except Exception as e:\r\n-            self.logger.error(f\"Volume calculation failed: {str(e)}\")\r\n-            return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n-                    \"condition\": condition, \"density\": 0.0,\r\n-                    \"error\": f\"Exception: {str(e)}\"}\r\n+            self.logger.error(f\"Error during calculation from segmentation: {e}\", exc_info=True)\r\n+            return None\r\n \r\n     def get_material_density(self, material_type: str, condition: str = None) -> float:\r\n-        \"\"\"\r\n-        Get the density of a material based on its type and condition.\r\n-\r\n-        Args:\r\n-            material_type (str): Type of material (e.g., 'Sand', 'Gravel')\r\n-            condition (str, optional): Condition of material (e.g., 'Dry', 'Wet', 'Compacted')\r\n-\r\n-        Returns:\r\n-            float: Material density in kg/m³\r\n-        \"\"\"\r\n+        \"\"\" Get the density of a material based on its type and condition. \"\"\"\r\n         try:\r\n-            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n+            material_type = material_type.strip().capitalize() if material_type else \"Gravel\"  # Default\r\n \r\n-            # If material type not found, return default density\r\n+            # Handle case where material type might not be in the dict\r\n             if material_type not in self.MATERIAL_DENSITIES:\r\n-                self.logger.warning(f\"Unknown material type: {material_type}, using default density\")\r\n-                return self.MATERIAL_DENSITIES['Other']\r\n+                self.logger.warning(f\"Unknown material type: {material_type}, using default density for 'Other'.\")\r\n+                # Check if 'Other' exists and is a float, otherwise use a hardcoded default\r\n+                return self.MATERIAL_DENSITIES.get('Other', 1800.0) if isinstance(self.MATERIAL_DENSITIES.get('Other'), float) else 1800.0\r\n \r\n             material_data = self.MATERIAL_DENSITIES[material_type]\r\n \r\n-            # If no condition specified or invalid condition, return average density\r\n-            if not condition or not isinstance(material_data, dict):\r\n-                # If material_data is NOT a dict (e.g., for 'Other': 1800.0),\r\n-                # material_data.values() will cause a TypeError because float is not iterable\r\n-                return material_data if isinstance(material_data, float) else sum(material_data.values()) / len(material_data)\r\n-\r\n-            condition = condition.strip().capitalize() if condition else None\r\n-            if condition in material_data:\r\n-                density = material_data[condition]\r\n+            # --- FIX for TypeError ---\r\n+            if isinstance(material_data, dict):\r\n+                # Material has conditions (like Sand, Gravel)\r\n+                condition = condition.strip().capitalize() if condition else None\r\n+                if condition and condition in material_data:\r\n+                    density = material_data[condition]\r\n+                else:\r\n+                    # Use average if condition invalid or not specified\r\n+                    avg_density = sum(material_data.values()) / len(material_data)\r\n+                    self.logger.warning(f\"Condition '{condition}' not found or not specified for {material_type}. Using average density: {avg_density:.2f} kg/m³\")\r\n+                    density = avg_density\r\n+            elif isinstance(material_data, (float, int)):\r\n+                # Material has a single density value (like 'Other')\r\n+                density = float(material_data)\r\n+                if condition:\r\n+                    self.logger.warning(f\"Condition '{condition}' specified but material '{material_type}' has no conditions. Using base density: {density:.2f} kg/m³\")\r\n             else:\r\n-                # Return average if condition not found\r\n-                self.logger.warning(f\"Unknown condition: {condition} for {material_type}, using average density\")\r\n-                density = sum(material_data.values()) / len(material_data)\r\n+                # Fallback if structure is unexpected\r\n+                self.logger.error(f\"Unexpected data structure for material '{material_type}'. Using default density.\")\r\n+                density = 1800.0\r\n+            # --- End FIX ---\r\n \r\n-            # Calculate specific gravity\r\n-            specific_gravity = density / 1000  # Convert kg/m³ to specific gravity (water density = 1000 kg/m³)\r\n-\r\n-            # Validate specific gravity against known ranges\r\n-            if material_type in self.MATERIAL_SPECIFIC_GRAVITY_RANGES:\r\n-                min_sg, max_sg = self.MATERIAL_SPECIFIC_GRAVITY_RANGES[material_type]\r\n-                if not (min_sg <= specific_gravity <= max_sg):\r\n-                    self.logger.warning(\r\n-                        f\"Specific gravity {specific_gravity} for {material_type} is outside expected range ({min_sg}-{max_sg})\")\r\n-\r\n+            self.logger.info(f\"Retrieved density for {material_type} ({condition or 'Base'}): {density:.2f} kg/m³\")\r\n             return density\r\n \r\n         except Exception as e:\r\n-            self.logger.error(f\"Error getting material density: {str(e)}\")\r\n-            return self.MATERIAL_DENSITIES['Other']\r\n+            self.logger.error(f\"Error getting material density: {e}\", exc_info=True)\r\n+            return 1800.0  # Return a default value on error\r\n \r\n     def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n                        density: Optional[float] = None) -> float:\r\n-        \"\"\"\r\n-        Calculate mass based on volume and material type.\r\n-\r\n-        Args:\r\n-            volume (float): Volume in cubic meters\r\n-            material_type (str): Type of material\r\n-            condition (str, optional): Condition of material\r\n-            density (float, optional): Override density if provided\r\n-\r\n-        Returns:\r\n-            float: Mass in metric tons\r\n-        \"\"\"\r\n+        \"\"\" Calculate mass in KG based on volume and material properties. \"\"\"\r\n+        if volume is None or volume < 0:\r\n+            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation. Returning 0.\")\r\n+            return 0.0\r\n         if density is None:\r\n             density = self.get_material_density(material_type, condition)\r\n-        return volume * density / 1000.0  # Convert to metric tons\r\n-\r\n-    def calibrate_density(self, known_mass: float, measured_volume: float, material_type: str = \"Sand\") -> float:\r\n-        \"\"\"\r\n-        Simple density calibration based on known mass and measured volume\r\n-\r\n-        Args:\r\n-            known_mass (float): Known mass in kg.\r\n-            measured_volume (float): Measured volume in m³.\r\n-            material_type (str): Type of material being calibrated.\r\n-        Returns:\r\n-            float: Calibrated density in kg/m³.\r\n-        \"\"\"\r\n-        if measured_volume <= 0:\r\n-            self.logger.error(\"Cannot calibrate with zero or negative volume\")\r\n-            return self.get_material_density(material_type)\r\n-\r\n-        # Use the actual measured mass/volume for calibration\r\n-        calibrated_density = known_mass / measured_volume\r\n-\r\n-        # Store the calibrated density\r\n-        self.calibrated_densities[material_type] = calibrated_density\r\n-\r\n-        self.logger.info(f\"Calibration for {material_type}:\")\r\n-        self.logger.info(f\"- Calibrated density: {calibrated_density:.2f} kg/m³\")\r\n-\r\n-        return calibrated_density\r\n-\r\n-    def _check_measurement_consistency(self, current_result: Dict[str, float]) -> Dict[str, float]:\r\n-        \"\"\"Check if current measurement is consistent with recent history\"\"\"\r\n-        # Extract recent volumes and masses\r\n-        recent_volumes = [r[\"total\"] for r in self.measurement_history[-3:] if \"total\" in r]\r\n-        recent_masses = [r[\"mass\"] for r in self.measurement_history[-3:] if \"mass\" in r and r[\"mass\"] is not None]\r\n-\r\n-        if not recent_volumes or not recent_masses:\r\n-            return current_result\r\n-\r\n-        # Calculate mean and standard deviation\r\n-        mean_volume = np.mean(recent_volumes)\r\n-        std_volume = np.std(recent_volumes)\r\n-        mean_mass = np.mean(recent_masses)\r\n-        std_mass = np.std(recent_masses)\r\n-\r\n-        # Check if current measurement is within reasonable bounds (3 standard deviations)\r\n-        if std_volume > 0 and abs(current_result[\"total\"] - mean_volume) > 3 * std_volume:\r\n-            self.logger.warning(\r\n-                f\"Volume measurement ({current_result['total']:.2f}) deviates significantly from recent average ({mean_volume:.2f}), std: {std_volume:.2f}\")\r\n-            # Apply smoothing\r\n-            current_result[\"total\"] = 0.7 * current_result[\"total\"] + 0.3 * mean_volume\r\n-            self.logger.info(f\"Adjusted volume to {current_result['total']:.2f}\")\r\n-\r\n-        if std_mass > 0 and abs(current_result[\"mass\"] - mean_mass) > 3 * std_mass:\r\n-            self.logger.warning(\r\n-                f\"Mass measurement ({current_result['mass']:.2f}) deviates significantly from recent average ({mean_mass:.2f}), std: {std_mass:.2f}\")\r\n-            # Apply smoothing\r\n-            current_result[\"mass\"] = 0.7 * current_result[\"mass\"] + 0.3 * mean_mass\r\n-            self.logger.info(f\"Adjusted mass to {current_result['mass']:.2f}\")\r\n-\r\n-        return current_result\r\n-\r\n-    def validate_material_properties(self, material_type: str, density: Optional[float] = None) -> Dict:\r\n-        \"\"\"\r\n-        Validate material properties and provide recommendations.\r\n-\r\n-        Args:\r\n-            material_type (str): Type of material\r\n-            density (float, optional): User-provided density\r\n-\r\n-        Returns:\r\n-            Dict: Validation results and recommendations\r\n-        \"\"\"\r\n-        result = {\r\n-            'valid': True,\r\n-            'message': '',\r\n-            'recommended_density': None,\r\n-            'density_range': None\r\n-        }\r\n-\r\n-        try:\r\n-            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n-            if material_type not in self.MATERIAL_DENSITIES:\r\n-                result['valid'] = False\r\n-                result['message'] = f\"Unknown material type: {material_type}\"\r\n-                return result\r\n-\r\n-            material_data = self.MATERIAL_DENSITIES[material_type]\r\n-            densities = list(material_data.values())\r\n-            min_density = min(densities)\r\n-            max_density = max(densities)\r\n-            avg_density = sum(densities) / len(densities)\r\n-\r\n-            result['density_range'] = (min_density, max_density)\r\n-            result['recommended_density'] = avg_density\r\n-\r\n-            if density is not None:\r\n-                if density < min_density * 0.5 or density > max_density * 1.5:\r\n-                    result['valid'] = False\r\n-                    result[\r\n-                        'message'] = f\"Density {density} kg/m³ is outside expected range ({min_density}-{max_density} kg/m³)\"\r\n-                elif density < min_density or density > max_density:\r\n-                    result['message'] = f\"Warning: Density {density} kg/m³ is unusual for {material_type}\"\r\n-\r\n-        except Exception as e:\r\n-            result['valid'] = False\r\n-            result['message'] = f\"Error validating properties: {str(e)}\"\r\n-\r\n-        return result\r\n-\r\n-    def get_material_conditions(self, material_type: str) -> list:\r\n-        \"\"\"\r\n-        Get available conditions for a material type.\r\n-\r\n-        Args:\r\n-            material_type (str): Type of material\r\n-\r\n-        Returns:\r\n-            list: Available conditions for the material\r\n-        \"\"\"\r\n-        try:\r\n-            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n-            if material_type in self.MATERIAL_DENSITIES:\r\n-                return list(self.MATERIAL_DENSITIES[material_type].keys())\r\n-            return []\r\n-        except Exception:\r\n-            return []\r\n-\r\n-    def get_available_materials(self) -> list:\r\n-        \"\"\"\r\n-        Get list of available material types.\r\n-\r\n-        Returns:\r\n-            list: Available material types\r\n-        \"\"\"\r\n-        return list(self.MATERIAL_DENSITIES.keys())\r\n-\r\n-    def adjust_sand_density(self, base_density: float,\r\n-                            moisture_content: float = 0.0,\r\n-                            compaction_level: str = \"loose\",\r\n-                            sand_type: str = \"standard\") -> float:\r\n-        \"\"\"\r\n-        Adjust sand density based on various factors.\r\n-\r\n-        Args:\r\n-            base_density: Base density in kg/m³\r\n-            moisture_content: Moisture percentage (0-100)\r\n-            compaction_level: \"loose\", \"medium\", or \"dense\"\r\n-            sand_type: Type of sand (\"fine\", \"coarse\", \"standard\")\r\n-\r\n-        Returns:\r\n-            Adjusted density in kg/m³\r\n-        \"\"\"\r\n-        # Moisture adjustment factor\r\n-        moisture_factor = 1 + (moisture_content / 100)\r\n-\r\n-        # Compaction adjustment\r\n-        compaction_factors = {\r\n-            \"loose\": 0.85,\r\n-            \"medium\": 1.0,\r\n-            \"dense\": 1.15\r\n-        }\r\n-        compaction_factor = compaction_factors.get(compaction_level, 1.0)\r\n-\r\n-        # Sand type adjustment\r\n-        sand_type_factors = {\r\n-            \"fine\": 0.95,\r\n-            \"standard\": 1.0,\r\n-            \"coarse\": 1.05\r\n-        }\r\n-        type_factor = sand_type_factors.get(sand_type, 1.0)\r\n-\r\n-        # Calculate adjusted density\r\n-        adjusted_density = base_density * moisture_factor * compaction_factor * type_factor\r\n-\r\n-        self.logger.info(f\"Adjusted sand density: {adjusted_density:.2f} kg/m³ \"\r\n-                         f\"(moisture: {moisture_content}%, compaction: {compaction_level}, type: {sand_type})\")\r\n-\r\n-        return adjusted_density\r\n-\r\n-    def calculate_conical_pile_volume(self, area: float, height: float) -> float:\r\n-        \"\"\"\r\n-        Calculate volume of a conical pile based on base area and height.\r\n-        Conical piles typically have 1/3 the volume of a cylinder with the same base and height.\r\n-\r\n-        Args:\r\n-            area: Base area in m²\r\n-            height: Height in m\r\n-\r\n-        Returns:\r\n-            Volume in m³\r\n-        \"\"\"\r\n-        cone_factor = 1 / 3\r\n-        volume = area * height * cone_factor\r\n-        return volume\r\n-\r\n-    def validate_results(self, calculated_result: Dict[str, float],\r\n-                         ground_truth: Dict[str, float]) -> Dict[str, float]:\r\n-        \"\"\"Calculate accuracy metrics for volume and mass.\"\"\"\r\n-        metrics = {}\r\n-\r\n-        # Validate volume\r\n-        if 'total' in calculated_result and 'volume' in ground_truth:\r\n-            vol_abs_error = abs(calculated_result['total'] - ground_truth['volume'])\r\n-            vol_rel_error = vol_abs_error / ground_truth['volume'] * 100 if ground_truth['volume'] > 0 else float('inf')\r\n-\r\n-            metrics.update({\r\n-                'volume_absolute_error': vol_abs_error,\r\n-                'volume_relative_error': vol_rel_error,\r\n-                'volume_rmse': np.sqrt(vol_abs_error ** 2)\r\n-            })\r\n-\r\n-        # Validate mass if density is provided\r\n-        if 'mass' in calculated_result and 'density' in ground_truth:\r\n-            true_mass = ground_truth['volume'] * ground_truth['density'] / 1000.0\r\n-            mass_abs_error = abs(calculated_result['mass'] - true_mass)\r\n-            mass_rel_error = mass_abs_error / true_mass * 100 if true_mass > 0 else float('inf')\r\n-\r\n-            metrics.update({\r\n-                'mass_absolute_error': mass_abs_error,\r\n-                'mass_relative_error': mass_rel_error,\r\n-                'mass_rmse': np.sqrt(mass_abs_error ** 2)\r\n-            })\r\n-\r\n-        return metrics\r\n-\r\n-\r\n-# Example usage\r\n-if __name__ == \"__main__\":\r\n-    # Configure logging\r\n-    logging.basicConfig(\r\n-        level=logging.INFO,\r\n-        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\r\n-    )\r\n-\r\n-logger = logging.getLogger(__name__)\r\n-\r\n-def calculate_damage(segmentation_result):\r\n-    \"\"\"\r\n-    Placeholder function to calculate damage metrics.\r\n-    Replace with your actual damage calculation logic.\r\n-\r\n-    Args:\r\n-        segmentation_result: Dictionary containing segmentation data (e.g., mask, contours).\r\n-\r\n-    Returns:\r\n-        A dictionary with damage metrics (e.g., {'crack_area_percentage': 5.2})\r\n-        or None if calculation fails.\r\n-    \"\"\"\r\n-    logger.info(\"Calculating damage (Placeholder)...\")\r\n-    if not segmentation_result or 'mask' not in segmentation_result:\r\n-        logger.warning(\"Invalid segmentation result for damage calculation.\")\r\n-        return None\r\n-\r\n-    # --- Placeholder Logic ---\r\n-    # Example: Calculate percentage of mask area relative to total image area\r\n-    mask = segmentation_result['mask']\r\n-    if mask is None or mask.size == 0:\r\n-         logger.warning(\"Mask is empty in segmentation result.\")\r\n-         return {'damage_description': 'No mask found'}\r\n-\r\n-    total_pixels = mask.size\r\n-    damage_pixels = np.count_nonzero(mask)\r\n-    damage_percentage = (damage_pixels / total_pixels) * 100 if total_pixels > 0 else 0\r\n-\r\n-    logger.info(f\"Placeholder damage calculated: {damage_percentage:.2f}% area\")\r\n-    # --- End Placeholder ---\r\n-\r\n-    # Return results in a dictionary\r\n-    return {\r\n-        'damage_area_percentage': round(damage_percentage, 2),\r\n-        'description': 'Calculated based on segmented mask area (Placeholder)'\r\n-    }\r\n-\r\n-\r\n-def calculate_volume(top_view_data, front_view_data):\r\n-    \"\"\"\r\n-    Placeholder function to calculate volume based on processed view data.\r\n-    Replace with your actual volume calculation logic using data from both views.\r\n-\r\n-    Args:\r\n-        top_view_data: Dictionary containing segmentation/processing results for the top view.\r\n-        front_view_data: Dictionary containing segmentation/processing results for the front view.\r\n-\r\n-    Returns:\r\n-        The calculated volume (float) or None if calculation fails.\r\n-    \"\"\"\r\n-    logger.info(\"Calculating volume (Placeholder)...\")\r\n-    if not top_view_data or not front_view_data:\r\n-        logger.warning(\"Missing view data for volume calculation.\")\r\n-        return None\r\n-\r\n-    # --- Placeholder Logic ---\r\n-    # Example: Use contour area from top view and assume a fixed height or estimate from front view\r\n-    top_mask = top_view_data.get('mask')\r\n-    if top_mask is None:\r\n-         logger.warning(\"Missing top view mask for volume calculation.\")\r\n-         return None\r\n-\r\n-    top_area_pixels = np.count_nonzero(top_mask)\r\n-    # This needs calibration: pixels to real-world area (e.g., pixels/m^2)\r\n-    pixels_per_square_meter = 10000 # Highly dependent on camera setup - MUST CALIBRATE\r\n-    top_area_m2 = top_area_pixels / pixels_per_square_meter\r\n-\r\n-    # Estimate height (e.g., from front view contours or fixed value)\r\n-    estimated_height_m = 0.5 # MUST BE DETERMINED from front view analysis or calibration\r\n-\r\n-    calculated_volume_m3 = top_area_m2 * estimated_height_m\r\n-    logger.info(f\"Placeholder volume calculated: {calculated_volume_m3:.2f} m³\")\r\n-    # --- End Placeholder ---\r\n-\r\n-    return round(calculated_volume_m3, 2)\r\n-\r\n-# Add any other necessary helper functions for calculations below\r\n+        mass_kg = volume * density\r\n+        self.logger.info(f\"Calculated mass: {mass_kg:.2f} kg (Volume: {volume:.4f} m³, Density: {density:.2f} kg/m³)\")\r\n+        return mass_kg  # Return mass in KG\r\n"
                },
                {
                    "date": 1745162351699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -120,9 +120,9 @@\n                     depth_m = h / self.PIXELS_PER_METER_HORIZONTAL  # Use horizontal scale for top-down depth\r\n \r\n                     points_3d = np.array([\r\n                         [0, 0, 0], [width_m, 0, 0], [width_m, depth_m, 0], [0, depth_m, 0],  # Bottom\r\n-                        [0, 0, estimated_height_m], [width_m, 0, estimated_height_m],        # Top\r\n+                        [0, 0, estimated_height_m], [width_m, 0, estimated_height_m],       # Top\r\n                         [width_m, depth_m, estimated_height_m], [0, depth_m, estimated_height_m]\r\n                     ])\r\n                     self.logger.info(\"Generated placeholder 3D bounding box points.\")\r\n \r\n@@ -197,11 +197,5 @@\n     def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n                        density: Optional[float] = None) -> float:\r\n         \"\"\" Calculate mass in KG based on volume and material properties. \"\"\"\r\n         if volume is None or volume < 0:\r\n-            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation. Returning 0.\")\r\n-            return 0.0\r\n-        if density is None:\r\n-            density = self.get_material_density(material_type, condition)\r\n-        mass_kg = volume * density\r\n-        self.logger.info(f\"Calculated mass: {mass_kg:.2f} kg (Volume: {volume:.4f} m³, Density: {density:.2f} kg/m³)\")\r\n-        return mass_kg  # Return mass in KG\r\n+            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745162363423,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -197,5 +197,5 @@\n     def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n                        density: Optional[float] = None) -> float:\r\n         \"\"\" Calculate mass in KG based on volume and material properties. \"\"\"\r\n         if volume is None or volume < 0:\r\n-            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation\n\\ No newline at end of file\n+            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation)\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745162370806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -197,5 +197,5 @@\n     def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n                        density: Optional[float] = None) -> float:\r\n         \"\"\" Calculate mass in KG based on volume and material properties. \"\"\"\r\n         if volume is None or volume < 0:\r\n-            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation)\n\\ No newline at end of file\n+            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation\n\\ No newline at end of file\n"
                },
                {
                    "date": 1745162395200,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -197,5 +197,5 @@\n     def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n                        density: Optional[float] = None) -> float:\r\n         \"\"\" Calculate mass in KG based on volume and material properties. \"\"\"\r\n         if volume is None or volume < 0:\r\n-            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation\n\\ No newline at end of file\n+            self.logger.warning(f\"Invalid volume ({volume}) for mass calculation)\n\\ No newline at end of file\n"
                }
            ],
            "date": 1745148027297,
            "name": "Commit-0",
            "content": "import numpy as np\r\nimport logging\r\nimport cv2\r\nfrom typing import Dict, Optional, Tuple, List, Union\r\n\r\n\r\nclass Calculation:\r\n    \"\"\"\r\n    Enhanced calculation class for material volume and mass calculations.\r\n    This class combines the functionality from the original Calculation class\r\n    and key calculations from MaterialProperties.\r\n    \"\"\"\r\n\r\n    # Define comprehensive material densities (kg/m³)\r\n    MATERIAL_DENSITIES = {\r\n        'Sand': {\r\n            'Dry': 1600.0,\r\n            'Wet': 1900.0,\r\n            'Compacted': 2000.0\r\n        },\r\n        'Gravel': {\r\n            'Loose': 1600.0,\r\n            'Compacted': 1900.0,\r\n            'Crushed': 1650.0,\r\n            'Wet': 1800.0,\r\n            'Dry': 1500.0\r\n        },\r\n        'Soil': {\r\n            'Dry': 1300.0,\r\n            'Wet': 1700.0,\r\n            'Compacted': 1900.0\r\n        },\r\n        'Rock': {\r\n            'Crushed': 1600.0,\r\n            'Solid': 2700.0,\r\n            'Wet': 2800.0\r\n        },\r\n        'Concrete': {\r\n            'Regular': 2400.0,\r\n            'Reinforced': 2500.0,\r\n            'Fresh': 2350.0\r\n        },\r\n        'Other': 1800.0  # Default density\r\n    }\r\n\r\n    # Define material specific gravity ranges\r\n    MATERIAL_SPECIFIC_GRAVITY_RANGES = {\r\n        \"Sand\": (2.65, 2.67),\r\n        \"Gravel\": (2.5, 3.0),\r\n        \"Concrete\": (2.3, 2.5),\r\n        \"Soil\": (1.1, 1.3),\r\n        \"Unknown\": (0, 0)\r\n    }\r\n\r\n    def __init__(self):\r\n        self.logger = logging.getLogger(__name__)\r\n        self.logger.setLevel(logging.INFO)\r\n        if not self.logger.handlers:\r\n            handler = logging.StreamHandler()\r\n            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\n            handler.setFormatter(formatter)\r\n            self.logger.addHandler(handler)\r\n\r\n        self.calibrated_densities = {}\r\n        self.measurement_history = []\r\n        self.MAX_HISTORY_SIZE = 10\r\n\r\n    def calculate_volume(self, volume_value: float, material_type: str = \"Sand\",\r\n                         condition: str = None, material_density: Optional[float] = None,\r\n                         known_mass: Optional[float] = None) -> Dict[str, float]:\r\n        \"\"\"\r\n        Volume and mass calculation with enhanced material property support\r\n\r\n        Args:\r\n            volume_value: The volume value in m³\r\n            material_type: Type of material (\"Sand\", \"Gravel\", \"Concrete\", \"Soil\", etc.)\r\n            condition: Material condition (e.g., 'Dry', 'Wet', 'Compacted')\r\n            material_density: Optional explicit density value in kg/m³\r\n            known_mass: Optional known mass in kg for calibration\r\n\r\n        Returns:\r\n            Dict with volume calculation results\r\n        \"\"\"\r\n        try:\r\n            # Validate the calculated volume\r\n            if volume_value <= 0 or np.isnan(volume_value) or np.isinf(volume_value):\r\n                self.logger.error(f\"Invalid volume calculation result: {volume_value}\")\r\n                return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n                        \"condition\": condition, \"density\": 0.0,\r\n                        \"error\": \"Invalid volume value\"}\r\n\r\n            # Get density using proper logic\r\n            if material_density is not None:\r\n                # Use explicitly provided density\r\n                self.logger.info(f\"Using explicitly provided density: {material_density} kg/m³\")\r\n            elif known_mass is not None:\r\n                # Calibrate density using the known mass\r\n                material_density = self.calibrate_density(known_mass, volume_value, material_type)\r\n                self.logger.info(f\"Using calibrated density: {material_density} kg/m³\")\r\n            else:\r\n                # Use enhanced get_material_density method\r\n                material_density = self.get_material_density(material_type, condition)\r\n                self.logger.info(f\"Using material density for {material_type} ({condition}): {material_density} kg/m³\")\r\n\r\n            # Calculate mass in metric tons\r\n            mass = self.calculate_mass(volume_value, material_type, condition, material_density)\r\n\r\n            # Store result in history for consistency checking\r\n            result = {\r\n                \"total\": volume_value,\r\n                \"mass\": mass,\r\n                \"material_type\": material_type,\r\n                \"condition\": condition,\r\n                \"density\": material_density,\r\n                \"timestamp\": None,  # Can be filled with actual timestamp if needed\r\n                \"error\": None\r\n            }\r\n\r\n            # Add to history and maintain maximum size\r\n            self.measurement_history.append(result)\r\n            if len(self.measurement_history) > self.MAX_HISTORY_SIZE:\r\n                self.measurement_history.pop(0)\r\n\r\n            # Only perform consistency check if we have enough history\r\n            if len(self.measurement_history) >= 3:\r\n                result = self._check_measurement_consistency(result)\r\n\r\n            self.logger.info(f\"Final volume calculation: {volume_value:.2f} m³, {mass:.2f} metric tons\")\r\n            return result\r\n\r\n        except Exception as e:\r\n            self.logger.error(f\"Volume calculation failed: {str(e)}\")\r\n            return {\"total\": 0.0, \"mass\": 0.0, \"material_type\": material_type,\r\n                    \"condition\": condition, \"density\": 0.0,\r\n                    \"error\": f\"Exception: {str(e)}\"}\r\n\r\n    def get_material_density(self, material_type: str, condition: str = None) -> float:\r\n        \"\"\"\r\n        Get the density of a material based on its type and condition.\r\n\r\n        Args:\r\n            material_type (str): Type of material (e.g., 'Sand', 'Gravel')\r\n            condition (str, optional): Condition of material (e.g., 'Dry', 'Wet', 'Compacted')\r\n\r\n        Returns:\r\n            float: Material density in kg/m³\r\n        \"\"\"\r\n        try:\r\n            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n\r\n            # If material type not found, return default density\r\n            if material_type not in self.MATERIAL_DENSITIES:\r\n                self.logger.warning(f\"Unknown material type: {material_type}, using default density\")\r\n                return self.MATERIAL_DENSITIES['Other']\r\n\r\n            material_data = self.MATERIAL_DENSITIES[material_type]\r\n\r\n            # If no condition specified or invalid condition, return average density\r\n            if not condition or not isinstance(material_data, dict):\r\n                return sum(material_data.values()) / len(material_data)\r\n\r\n            condition = condition.strip().capitalize() if condition else None\r\n            if condition in material_data:\r\n                density = material_data[condition]\r\n            else:\r\n                # Return average if condition not found\r\n                self.logger.warning(f\"Unknown condition: {condition} for {material_type}, using average density\")\r\n                density = sum(material_data.values()) / len(material_data)\r\n\r\n            # Calculate specific gravity\r\n            specific_gravity = density / 1000  # Convert kg/m³ to specific gravity (water density = 1000 kg/m³)\r\n\r\n            # Validate specific gravity against known ranges\r\n            if material_type in self.MATERIAL_SPECIFIC_GRAVITY_RANGES:\r\n                min_sg, max_sg = self.MATERIAL_SPECIFIC_GRAVITY_RANGES[material_type]\r\n                if not (min_sg <= specific_gravity <= max_sg):\r\n                    self.logger.warning(\r\n                        f\"Specific gravity {specific_gravity} for {material_type} is outside expected range ({min_sg}-{max_sg})\")\r\n\r\n            return density\r\n\r\n        except Exception as e:\r\n            self.logger.error(f\"Error getting material density: {str(e)}\")\r\n            return self.MATERIAL_DENSITIES['Other']\r\n\r\n    def calculate_mass(self, volume: float, material_type: str, condition: str = None,\r\n                       density: Optional[float] = None) -> float:\r\n        \"\"\"\r\n        Calculate mass based on volume and material type.\r\n\r\n        Args:\r\n            volume (float): Volume in cubic meters\r\n            material_type (str): Type of material\r\n            condition (str, optional): Condition of material\r\n            density (float, optional): Override density if provided\r\n\r\n        Returns:\r\n            float: Mass in metric tons\r\n        \"\"\"\r\n        if density is None:\r\n            density = self.get_material_density(material_type, condition)\r\n        return volume * density / 1000.0  # Convert to metric tons\r\n\r\n    def calibrate_density(self, known_mass: float, measured_volume: float, material_type: str = \"Sand\") -> float:\r\n        \"\"\"\r\n        Simple density calibration based on known mass and measured volume\r\n\r\n        Args:\r\n            known_mass (float): Known mass in kg.\r\n            measured_volume (float): Measured volume in m³.\r\n            material_type (str): Type of material being calibrated.\r\n        Returns:\r\n            float: Calibrated density in kg/m³.\r\n        \"\"\"\r\n        if measured_volume <= 0:\r\n            self.logger.error(\"Cannot calibrate with zero or negative volume\")\r\n            return self.get_material_density(material_type)\r\n\r\n        # Use the actual measured mass/volume for calibration\r\n        calibrated_density = known_mass / measured_volume\r\n\r\n        # Store the calibrated density\r\n        self.calibrated_densities[material_type] = calibrated_density\r\n\r\n        self.logger.info(f\"Calibration for {material_type}:\")\r\n        self.logger.info(f\"- Calibrated density: {calibrated_density:.2f} kg/m³\")\r\n\r\n        return calibrated_density\r\n\r\n    def _check_measurement_consistency(self, current_result: Dict[str, float]) -> Dict[str, float]:\r\n        \"\"\"Check if current measurement is consistent with recent history\"\"\"\r\n        # Extract recent volumes and masses\r\n        recent_volumes = [r[\"total\"] for r in self.measurement_history[-3:] if \"total\" in r]\r\n        recent_masses = [r[\"mass\"] for r in self.measurement_history[-3:] if \"mass\" in r and r[\"mass\"] is not None]\r\n\r\n        if not recent_volumes or not recent_masses:\r\n            return current_result\r\n\r\n        # Calculate mean and standard deviation\r\n        mean_volume = np.mean(recent_volumes)\r\n        std_volume = np.std(recent_volumes)\r\n        mean_mass = np.mean(recent_masses)\r\n        std_mass = np.std(recent_masses)\r\n\r\n        # Check if current measurement is within reasonable bounds (3 standard deviations)\r\n        if std_volume > 0 and abs(current_result[\"total\"] - mean_volume) > 3 * std_volume:\r\n            self.logger.warning(\r\n                f\"Volume measurement ({current_result['total']:.2f}) deviates significantly from recent average ({mean_volume:.2f}), std: {std_volume:.2f}\")\r\n            # Apply smoothing\r\n            current_result[\"total\"] = 0.7 * current_result[\"total\"] + 0.3 * mean_volume\r\n            self.logger.info(f\"Adjusted volume to {current_result['total']:.2f}\")\r\n\r\n        if std_mass > 0 and abs(current_result[\"mass\"] - mean_mass) > 3 * std_mass:\r\n            self.logger.warning(\r\n                f\"Mass measurement ({current_result['mass']:.2f}) deviates significantly from recent average ({mean_mass:.2f}), std: {std_mass:.2f}\")\r\n            # Apply smoothing\r\n            current_result[\"mass\"] = 0.7 * current_result[\"mass\"] + 0.3 * mean_mass\r\n            self.logger.info(f\"Adjusted mass to {current_result['mass']:.2f}\")\r\n\r\n        return current_result\r\n\r\n    def validate_material_properties(self, material_type: str, density: Optional[float] = None) -> Dict:\r\n        \"\"\"\r\n        Validate material properties and provide recommendations.\r\n\r\n        Args:\r\n            material_type (str): Type of material\r\n            density (float, optional): User-provided density\r\n\r\n        Returns:\r\n            Dict: Validation results and recommendations\r\n        \"\"\"\r\n        result = {\r\n            'valid': True,\r\n            'message': '',\r\n            'recommended_density': None,\r\n            'density_range': None\r\n        }\r\n\r\n        try:\r\n            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n            if material_type not in self.MATERIAL_DENSITIES:\r\n                result['valid'] = False\r\n                result['message'] = f\"Unknown material type: {material_type}\"\r\n                return result\r\n\r\n            material_data = self.MATERIAL_DENSITIES[material_type]\r\n            densities = list(material_data.values())\r\n            min_density = min(densities)\r\n            max_density = max(densities)\r\n            avg_density = sum(densities) / len(densities)\r\n\r\n            result['density_range'] = (min_density, max_density)\r\n            result['recommended_density'] = avg_density\r\n\r\n            if density is not None:\r\n                if density < min_density * 0.5 or density > max_density * 1.5:\r\n                    result['valid'] = False\r\n                    result[\r\n                        'message'] = f\"Density {density} kg/m³ is outside expected range ({min_density}-{max_density} kg/m³)\"\r\n                elif density < min_density or density > max_density:\r\n                    result['message'] = f\"Warning: Density {density} kg/m³ is unusual for {material_type}\"\r\n\r\n        except Exception as e:\r\n            result['valid'] = False\r\n            result['message'] = f\"Error validating properties: {str(e)}\"\r\n\r\n        return result\r\n\r\n    def get_material_conditions(self, material_type: str) -> list:\r\n        \"\"\"\r\n        Get available conditions for a material type.\r\n\r\n        Args:\r\n            material_type (str): Type of material\r\n\r\n        Returns:\r\n            list: Available conditions for the material\r\n        \"\"\"\r\n        try:\r\n            material_type = material_type.strip().capitalize() if material_type else \"Sand\"\r\n            if material_type in self.MATERIAL_DENSITIES:\r\n                return list(self.MATERIAL_DENSITIES[material_type].keys())\r\n            return []\r\n        except Exception:\r\n            return []\r\n\r\n    def get_available_materials(self) -> list:\r\n        \"\"\"\r\n        Get list of available material types.\r\n\r\n        Returns:\r\n            list: Available material types\r\n        \"\"\"\r\n        return list(self.MATERIAL_DENSITIES.keys())\r\n\r\n    def adjust_sand_density(self, base_density: float,\r\n                            moisture_content: float = 0.0,\r\n                            compaction_level: str = \"loose\",\r\n                            sand_type: str = \"standard\") -> float:\r\n        \"\"\"\r\n        Adjust sand density based on various factors.\r\n\r\n        Args:\r\n            base_density: Base density in kg/m³\r\n            moisture_content: Moisture percentage (0-100)\r\n            compaction_level: \"loose\", \"medium\", or \"dense\"\r\n            sand_type: Type of sand (\"fine\", \"coarse\", \"standard\")\r\n\r\n        Returns:\r\n            Adjusted density in kg/m³\r\n        \"\"\"\r\n        # Moisture adjustment factor\r\n        moisture_factor = 1 + (moisture_content / 100)\r\n\r\n        # Compaction adjustment\r\n        compaction_factors = {\r\n            \"loose\": 0.85,\r\n            \"medium\": 1.0,\r\n            \"dense\": 1.15\r\n        }\r\n        compaction_factor = compaction_factors.get(compaction_level, 1.0)\r\n\r\n        # Sand type adjustment\r\n        sand_type_factors = {\r\n            \"fine\": 0.95,\r\n            \"standard\": 1.0,\r\n            \"coarse\": 1.05\r\n        }\r\n        type_factor = sand_type_factors.get(sand_type, 1.0)\r\n\r\n        # Calculate adjusted density\r\n        adjusted_density = base_density * moisture_factor * compaction_factor * type_factor\r\n\r\n        self.logger.info(f\"Adjusted sand density: {adjusted_density:.2f} kg/m³ \"\r\n                         f\"(moisture: {moisture_content}%, compaction: {compaction_level}, type: {sand_type})\")\r\n\r\n        return adjusted_density\r\n\r\n    def calculate_conical_pile_volume(self, area: float, height: float) -> float:\r\n        \"\"\"\r\n        Calculate volume of a conical pile based on base area and height.\r\n        Conical piles typically have 1/3 the volume of a cylinder with the same base and height.\r\n\r\n        Args:\r\n            area: Base area in m²\r\n            height: Height in m\r\n\r\n        Returns:\r\n            Volume in m³\r\n        \"\"\"\r\n        cone_factor = 1 / 3\r\n        volume = area * height * cone_factor\r\n        return volume\r\n\r\n    def validate_results(self, calculated_result: Dict[str, float],\r\n                         ground_truth: Dict[str, float]) -> Dict[str, float]:\r\n        \"\"\"Calculate accuracy metrics for volume and mass.\"\"\"\r\n        metrics = {}\r\n\r\n        # Validate volume\r\n        if 'total' in calculated_result and 'volume' in ground_truth:\r\n            vol_abs_error = abs(calculated_result['total'] - ground_truth['volume'])\r\n            vol_rel_error = vol_abs_error / ground_truth['volume'] * 100 if ground_truth['volume'] > 0 else float('inf')\r\n\r\n            metrics.update({\r\n                'volume_absolute_error': vol_abs_error,\r\n                'volume_relative_error': vol_rel_error,\r\n                'volume_rmse': np.sqrt(vol_abs_error ** 2)\r\n            })\r\n\r\n        # Validate mass if density is provided\r\n        if 'mass' in calculated_result and 'density' in ground_truth:\r\n            true_mass = ground_truth['volume'] * ground_truth['density'] / 1000.0\r\n            mass_abs_error = abs(calculated_result['mass'] - true_mass)\r\n            mass_rel_error = mass_abs_error / true_mass * 100 if true_mass > 0 else float('inf')\r\n\r\n            metrics.update({\r\n                'mass_absolute_error': mass_abs_error,\r\n                'mass_relative_error': mass_rel_error,\r\n                'mass_rmse': np.sqrt(mass_abs_error ** 2)\r\n            })\r\n\r\n        return metrics\r\n\r\n\r\n# Example usage\r\nif __name__ == \"__main__\":\r\n    # Configure logging\r\n    logging.basicConfig(\r\n        level=logging.INFO,\r\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\r\n    )\r\n\r\nlogger = logging.getLogger(__name__)\r\n\r\ndef calculate_damage(segmentation_result):\r\n    \"\"\"\r\n    Placeholder function to calculate damage metrics.\r\n    Replace with your actual damage calculation logic.\r\n\r\n    Args:\r\n        segmentation_result: Dictionary containing segmentation data (e.g., mask, contours).\r\n\r\n    Returns:\r\n        A dictionary with damage metrics (e.g., {'crack_area_percentage': 5.2})\r\n        or None if calculation fails.\r\n    \"\"\"\r\n    logger.info(\"Calculating damage (Placeholder)...\")\r\n    if not segmentation_result or 'mask' not in segmentation_result:\r\n        logger.warning(\"Invalid segmentation result for damage calculation.\")\r\n        return None\r\n\r\n    # --- Placeholder Logic ---\r\n    # Example: Calculate percentage of mask area relative to total image area\r\n    mask = segmentation_result['mask']\r\n    if mask is None or mask.size == 0:\r\n         logger.warning(\"Mask is empty in segmentation result.\")\r\n         return {'damage_description': 'No mask found'}\r\n\r\n    total_pixels = mask.size\r\n    damage_pixels = np.count_nonzero(mask)\r\n    damage_percentage = (damage_pixels / total_pixels) * 100 if total_pixels > 0 else 0\r\n\r\n    logger.info(f\"Placeholder damage calculated: {damage_percentage:.2f}% area\")\r\n    # --- End Placeholder ---\r\n\r\n    # Return results in a dictionary\r\n    return {\r\n        'damage_area_percentage': round(damage_percentage, 2),\r\n        'description': 'Calculated based on segmented mask area (Placeholder)'\r\n    }\r\n\r\n\r\ndef calculate_volume(top_view_data, front_view_data):\r\n    \"\"\"\r\n    Placeholder function to calculate volume based on processed view data.\r\n    Replace with your actual volume calculation logic using data from both views.\r\n\r\n    Args:\r\n        top_view_data: Dictionary containing segmentation/processing results for the top view.\r\n        front_view_data: Dictionary containing segmentation/processing results for the front view.\r\n\r\n    Returns:\r\n        The calculated volume (float) or None if calculation fails.\r\n    \"\"\"\r\n    logger.info(\"Calculating volume (Placeholder)...\")\r\n    if not top_view_data or not front_view_data:\r\n        logger.warning(\"Missing view data for volume calculation.\")\r\n        return None\r\n\r\n    # --- Placeholder Logic ---\r\n    # Example: Use contour area from top view and assume a fixed height or estimate from front view\r\n    top_mask = top_view_data.get('mask')\r\n    if top_mask is None:\r\n         logger.warning(\"Missing top view mask for volume calculation.\")\r\n         return None\r\n\r\n    top_area_pixels = np.count_nonzero(top_mask)\r\n    # This needs calibration: pixels to real-world area (e.g., pixels/m^2)\r\n    pixels_per_square_meter = 10000 # Highly dependent on camera setup - MUST CALIBRATE\r\n    top_area_m2 = top_area_pixels / pixels_per_square_meter\r\n\r\n    # Estimate height (e.g., from front view contours or fixed value)\r\n    estimated_height_m = 0.5 # MUST BE DETERMINED from front view analysis or calibration\r\n\r\n    calculated_volume_m3 = top_area_m2 * estimated_height_m\r\n    logger.info(f\"Placeholder volume calculated: {calculated_volume_m3:.2f} m³\")\r\n    # --- End Placeholder ---\r\n\r\n    return round(calculated_volume_m3, 2)\r\n\r\n# Add any other necessary helper functions for calculations below\r\n"
        }
    ]
}