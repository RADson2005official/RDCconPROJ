{
    "sourceFile": "App/routes.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1745145120355,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1745148042515,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,13 +1,14 @@\n-from flask import render_template, request, jsonify, redirect, url_for, flash, current_app\r\n+from flask import render_template, request, jsonify, redirect, url_for, flash, current_app, send_from_directory\r\n import os\r\n+import time\r\n from werkzeug.utils import secure_filename\r\n from App import app\r\n-from App.Utils.ImageLoader import ImageLoader\r\n-from App.Utils.ImageProcessor import ImageProcessor\r\n-from App.Utils.segmentation import perform_segmentation\r\n-from App.Utils.Calculation import calculate_damage\r\n-from App.Utils.Visualizer import visualize_results\r\n+from .Utils.ImageLoader import ImageLoader\r\n+from .Utils.ImageProcessor import ImageProcessor\r\n+from .Utils.segmentation import perform_segmentation\r\n+from .Utils.Calculation import calculate_damage, calculate_volume\r\n+from .Utils.Visualizer import visualize_results\r\n \r\n # Helper function to check if a file has an allowed extension\r\n def allowed_file(filename):\r\n     return '.' in filename and \\\r\n"
                },
                {
                    "date": 1745148196232,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,15 @@\n from flask import render_template, request, jsonify, redirect, url_for, flash, current_app, send_from_directory\r\n import os\r\n import time\r\n+import numpy as np  # Add numpy import if needed for data handling\r\n from werkzeug.utils import secure_filename\r\n-from App import app\r\n+from App import app  # Import the app instance\r\n from .Utils.ImageLoader import ImageLoader\r\n from .Utils.ImageProcessor import ImageProcessor\r\n from .Utils.segmentation import perform_segmentation\r\n from .Utils.Calculation import calculate_damage, calculate_volume\r\n-from .Utils.Visualizer import visualize_results\r\n+from .Utils.Visualizer import visualize_results, Visualizer\r\n \r\n # Helper function to check if a file has an allowed extension\r\n def allowed_file(filename):\r\n     return '.' in filename and \\\r\n@@ -100,8 +101,107 @@\n         # Log the exception for debugging\r\n         current_app.logger.error(f\"Error processing image {image_path}: {e}\")\r\n         return jsonify({'error': 'An internal error occurred during image processing.'}), 500\r\n \r\n+@app.route('/process_uploaded_images', methods=['POST'])\r\n+def process_uploaded_images_route():\r\n+    \"\"\"\r\n+    Handles processing of uploaded top and front view images via POST request.\r\n+    Expects 'topImageFile' and 'frontImageFile' in request.files.\r\n+    \"\"\"\r\n+    start_time = time.time()\r\n+    current_app.logger.info(\"Received request for /process_uploaded_images\")\r\n+\r\n+    top_file = request.files.get('topImageFile')\r\n+    front_file = request.files.get('frontImageFile')\r\n+\r\n+    if top_file and allowed_file(top_file.filename) and front_file and allowed_file(front_file.filename):\r\n+        try:\r\n+            ts = int(time.time())\r\n+            upload_folder = current_app.config['UPLOAD_FOLDER']\r\n+            if not os.path.exists(upload_folder):\r\n+                os.makedirs(upload_folder)\r\n+\r\n+            top_filepath = os.path.join(upload_folder, f\"top_{ts}_{secure_filename(top_file.filename)}\")\r\n+            front_filepath = os.path.join(upload_folder, f\"front_{ts}_{secure_filename(front_file.filename)}\")\r\n+            top_file.save(top_filepath)\r\n+            front_file.save(front_filepath)\r\n+\r\n+            # --- Processing Pipeline ---\r\n+            # 1. Load\r\n+            loader = ImageLoader()\r\n+            top_image = loader.load_image(top_filepath)\r\n+            front_image = loader.load_image(front_filepath)\r\n+            if top_image is None or front_image is None:\r\n+                raise ValueError(\"Failed to load one or both images\")\r\n+\r\n+            # 2. Preprocess (Adapt as needed)\r\n+            processor = ImageProcessor()\r\n+            processed_top = processor.preprocess(top_image)  # Assuming preprocess exists\r\n+            processed_front = processor.preprocess(front_image)\r\n+            if processed_top is None or processed_front is None:\r\n+                raise ValueError(\"Failed to preprocess one or both images\")\r\n+\r\n+            # 3. Segment\r\n+            top_seg_data = perform_segmentation(processed_top)\r\n+            front_seg_data = perform_segmentation(processed_front)\r\n+            if top_seg_data is None or front_seg_data is None:\r\n+                raise ValueError(\"Segmentation failed for one or both images\")\r\n+\r\n+            # 4. Calculate Volume (Adapt based on actual function signature/return)\r\n+            calculation_result = calculate_volume(top_seg_data, front_seg_data)\r\n+            if calculation_result is None or 'volume' not in calculation_result:\r\n+                raise ValueError(\"Volume calculation failed or did not return volume\")\r\n+            calculated_volume = calculation_result['volume']\r\n+            calculated_points = calculation_result.get('points')  # Placeholder name\r\n+\r\n+            # 5. Visualize using the Class\r\n+            viz_relative_path = None\r\n+            try:\r\n+                visualizer = Visualizer()\r\n+                if calculated_points is not None:\r\n+                    visualizer.plot_cube(corners_3d=calculated_points, volume=calculated_volume)\r\n+\r\n+                    results_folder = os.path.join(current_app.static_folder, 'results')\r\n+                    if not os.path.exists(results_folder):\r\n+                        os.makedirs(results_folder)\r\n+                    viz_filename = f\"visualization_{ts}.png\"\r\n+                    viz_abs_path = os.path.join(results_folder, viz_filename)\r\n+\r\n+                    visualizer.save_figure(viz_abs_path)\r\n+\r\n+                    viz_relative_path = os.path.join('results', viz_filename).replace('\\\\', '/')\r\n+                    current_app.logger.info(f\"Visualization saved to {viz_abs_path}\")\r\n+                else:\r\n+                    current_app.logger.warning(\"No 3D points available from calculation for visualization.\")\r\n+\r\n+            except Exception as viz_err:\r\n+                current_app.logger.error(f\"Error during visualization: {viz_err}\", exc_info=True)\r\n+\r\n+            # 6. Prepare Response\r\n+            processing_time = time.time() - start_time\r\n+            current_app.logger.info(f\"Processing complete. Volume: {calculated_volume}, Time: {processing_time:.2f}s\")\r\n+\r\n+            response_data = {\r\n+                'status': 'success',\r\n+                'volume': calculated_volume,\r\n+                'unit': 'm³',\r\n+                'processing_time': round(processing_time, 2),\r\n+                'timestamp': time.strftime(\"%Y-%m-%d %H:%M:%S\"),\r\n+                'visualization_url': None\r\n+            }\r\n+            if viz_relative_path:\r\n+                response_data['visualization_url'] = url_for('static', filename=viz_relative_path)\r\n+\r\n+            return jsonify(response_data)\r\n+\r\n+        except Exception as e:\r\n+            current_app.logger.error(f\"Error during image processing pipeline: {e}\", exc_info=True)\r\n+            return jsonify({'error': f'An internal error occurred: {e}'}), 500\r\n+    else:\r\n+        flash('Invalid file type or missing files')\r\n+        return redirect(url_for('index'))\r\n+\r\n @app.route('/about')\r\n def about():\r\n     \"\"\"Render the about page.\"\"\"\r\n     return render_template('about.html')\r\n"
                },
                {
                    "date": 1745148321894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -7,9 +7,9 @@\n from .Utils.ImageLoader import ImageLoader\r\n from .Utils.ImageProcessor import ImageProcessor\r\n from .Utils.segmentation import perform_segmentation\r\n from .Utils.Calculation import calculate_damage, calculate_volume\r\n-from .Utils.Visualizer import visualize_results, Visualizer\r\n+from .Utils.Visualizer import Visualizer\r\n \r\n # Helper function to check if a file has an allowed extension\r\n def allowed_file(filename):\r\n     return '.' in filename and \\\r\n"
                },
                {
                    "date": 1745149062827,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -115,23 +115,46 @@\n     front_file = request.files.get('frontImageFile')\r\n \r\n     if top_file and allowed_file(top_file.filename) and front_file and allowed_file(front_file.filename):\r\n         try:\r\n+            # --- Get Upload Folder Path ---\r\n+            # Use the absolute path stored during init if available, otherwise construct it\r\n+            upload_folder = app.config.get('UPLOAD_FOLDER_ABS')\r\n+            if not upload_folder:  # Fallback if not set in config during init\r\n+                upload_folder_config = app.config.get('UPLOAD_FOLDER')\r\n+                # Assuming BASE_DIR is project root in config\r\n+                project_root = app.config.get('BASE_DIR', os.path.dirname(os.path.dirname(__file__)))\r\n+                upload_folder = os.path.join(project_root, upload_folder_config)\r\n+                current_app.logger.warning(f\"UPLOAD_FOLDER_ABS not found in config, constructed path: {upload_folder}\")\r\n+\r\n+            if not upload_folder or not os.path.isdir(upload_folder):\r\n+                msg = f\"Upload folder is not configured correctly or does not exist: {upload_folder}\"\r\n+                current_app.logger.error(msg)\r\n+                return jsonify({'error': msg}), 500\r\n+\r\n+            # --- Save Files ---\r\n             ts = int(time.time())\r\n-            upload_folder = current_app.config['UPLOAD_FOLDER']\r\n-            if not os.path.exists(upload_folder):\r\n-                os.makedirs(upload_folder)\r\n+            top_filename = secure_filename(f\"top_{ts}_{top_file.filename}\")\r\n+            front_filename = secure_filename(f\"front_{ts}_{front_file.filename}\")\r\n+            top_filepath = os.path.join(upload_folder, top_filename)\r\n+            front_filepath = os.path.join(upload_folder, front_filename)\r\n \r\n-            top_filepath = os.path.join(upload_folder, f\"top_{ts}_{secure_filename(top_file.filename)}\")\r\n-            front_filepath = os.path.join(upload_folder, f\"front_{ts}_{secure_filename(front_file.filename)}\")\r\n+            current_app.logger.info(f\"Saving top image to: {top_filepath}\")\r\n             top_file.save(top_filepath)\r\n+            current_app.logger.info(f\"Saving front image to: {front_filepath}\")\r\n             front_file.save(front_filepath)\r\n \r\n             # --- Processing Pipeline ---\r\n             # 1. Load\r\n-            loader = ImageLoader()\r\n+            # --- FIX: Provide the upload_folder to ImageLoader ---\r\n+            # Note: This assumes ImageLoader's load_image method still needs the full path,\r\n+            # even though the class is initialized with the directory. Review ImageLoader logic.\r\n+            loader = ImageLoader(image_dir=upload_folder)\r\n+\r\n+            # Assuming load_image takes the full path (adjust if it takes filename only)\r\n             top_image = loader.load_image(top_filepath)\r\n             front_image = loader.load_image(front_filepath)\r\n+\r\n             if top_image is None or front_image is None:\r\n                 raise ValueError(\"Failed to load one or both images\")\r\n \r\n             # 2. Preprocess (Adapt as needed)\r\n@@ -159,22 +182,16 @@\n             try:\r\n                 visualizer = Visualizer()\r\n                 if calculated_points is not None:\r\n                     visualizer.plot_cube(corners_3d=calculated_points, volume=calculated_volume)\r\n-\r\n                     results_folder = os.path.join(current_app.static_folder, 'results')\r\n-                    if not os.path.exists(results_folder):\r\n-                        os.makedirs(results_folder)\r\n                     viz_filename = f\"visualization_{ts}.png\"\r\n                     viz_abs_path = os.path.join(results_folder, viz_filename)\r\n-\r\n                     visualizer.save_figure(viz_abs_path)\r\n-\r\n                     viz_relative_path = os.path.join('results', viz_filename).replace('\\\\', '/')\r\n                     current_app.logger.info(f\"Visualization saved to {viz_abs_path}\")\r\n                 else:\r\n                     current_app.logger.warning(\"No 3D points available from calculation for visualization.\")\r\n-\r\n             except Exception as viz_err:\r\n                 current_app.logger.error(f\"Error during visualization: {viz_err}\", exc_info=True)\r\n \r\n             # 6. Prepare Response\r\n@@ -197,10 +214,12 @@\n         except Exception as e:\r\n             current_app.logger.error(f\"Error during image processing pipeline: {e}\", exc_info=True)\r\n             return jsonify({'error': f'An internal error occurred: {e}'}), 500\r\n     else:\r\n-        flash('Invalid file type or missing files')\r\n-        return redirect(url_for('index'))\r\n+        allowed = app.config.get('ALLOWED_EXTENSIONS', set())\r\n+        msg = f\"Invalid file type. Allowed: {', '.join(allowed)}\"\r\n+        current_app.logger.error(msg)\r\n+        return jsonify({'error': msg}), 400\r\n \r\n @app.route('/about')\r\n def about():\r\n     \"\"\"Render the about page.\"\"\"\r\n"
                },
                {
                    "date": 1745150072845,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,14 +144,9 @@\n             front_file.save(front_filepath)\r\n \r\n             # --- Processing Pipeline ---\r\n             # 1. Load\r\n-            # --- FIX: Provide the upload_folder to ImageLoader ---\r\n-            # Note: This assumes ImageLoader's load_image method still needs the full path,\r\n-            # even though the class is initialized with the directory. Review ImageLoader logic.\r\n             loader = ImageLoader(image_dir=upload_folder)\r\n-\r\n-            # Assuming load_image takes the full path (adjust if it takes filename only)\r\n             top_image = loader.load_image(top_filepath)\r\n             front_image = loader.load_image(front_filepath)\r\n \r\n             if top_image is None or front_image is None:\r\n"
                },
                {
                    "date": 1745150294290,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -153,10 +153,10 @@\n                 raise ValueError(\"Failed to load one or both images\")\r\n \r\n             # 2. Preprocess (Adapt as needed)\r\n             processor = ImageProcessor()\r\n-            processed_top = processor.preprocess(top_image)  # Assuming preprocess exists\r\n-            processed_front = processor.preprocess(front_image)\r\n+            processed_top = processor.preprocess_image(top_image)  # Assuming preprocess_image exists\r\n+            processed_front = processor.preprocess_image(front_image)\r\n             if processed_top is None or processed_front is None:\r\n                 raise ValueError(\"Failed to preprocess one or both images\")\r\n \r\n             # 3. Segment\r\n"
                },
                {
                    "date": 1745161062972,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,162 +1,87 @@\n from flask import render_template, request, jsonify, redirect, url_for, flash, current_app, send_from_directory\r\n import os\r\n import time\r\n-import numpy as np  # Add numpy import if needed for data handling\r\n+import numpy as np\r\n from werkzeug.utils import secure_filename\r\n from App import app  # Import the app instance\r\n+import logging  # Import logging\r\n+\r\n+# Use relative imports for Utils within the same package\r\n from .Utils.ImageLoader import ImageLoader\r\n from .Utils.ImageProcessor import ImageProcessor\r\n-from .Utils.segmentation import perform_segmentation\r\n-from .Utils.Calculation import calculate_damage, calculate_volume\r\n+from .Utils.segmentation import perform_segmentation, visualize_segmentation\r\n+from .Utils.Calculation import Calculation\r\n from .Utils.Visualizer import Visualizer\r\n \r\n-# Helper function to check if a file has an allowed extension\r\n+# Allowed extensions\r\n+ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'bmp'}\r\n def allowed_file(filename):\r\n     return '.' in filename and \\\r\n-           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']\r\n+           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\r\n \r\n @app.route('/')\r\n def index():\r\n     \"\"\"Render the main page.\"\"\"\r\n     return render_template('main.html')\r\n \r\n-@app.route('/upload', methods=['POST'])\r\n-def upload_file():\r\n-    \"\"\"Handle file upload.\"\"\"\r\n-    # Check if the post request has the file part\r\n-    if 'file' not in request.files:\r\n-        flash('No file part')\r\n-        return redirect(request.url)\r\n+@app.route('/about')\r\n+def about():\r\n+    \"\"\"Render the about page.\"\"\"\r\n+    return render_template('about.html')\r\n \r\n-    file = request.files['file']\r\n-\r\n-    # If user does not select file, browser also submits an empty part without filename\r\n-    if file.filename == '':\r\n-        flash('No selected file')\r\n-        return redirect(request.url)\r\n-\r\n-    if file and allowed_file(file.filename):\r\n-        filename = secure_filename(file.filename)\r\n-        # Ensure the upload folder exists\r\n-        upload_folder = current_app.config['UPLOAD_FOLDER']\r\n-        if not os.path.exists(upload_folder):\r\n-            os.makedirs(upload_folder)\r\n-        filepath = os.path.join(upload_folder, filename)\r\n-        file.save(filepath)\r\n-\r\n-        # Process the image and return results\r\n-        return process_image(filepath)\r\n-\r\n-    flash('File type not allowed')\r\n-    return redirect(url_for('index'))\r\n-\r\n-@app.route('/process', methods=['POST'])\r\n-def process_image_route():\r\n-    \"\"\"Process an image with a provided path.\"\"\"\r\n-    data = request.get_json()\r\n-    image_path = data.get('image_path')\r\n-\r\n-    if not image_path or not os.path.exists(image_path):\r\n-        return jsonify({'error': 'Invalid image path'}), 400\r\n-\r\n-    return process_image(image_path)\r\n-\r\n-def process_image(image_path):\r\n-    \"\"\"Process the image through the concrete damage detection pipeline.\"\"\"\r\n-    try:\r\n-        # Load the image\r\n-        image_loader = ImageLoader()\r\n-        image = image_loader.load_image(image_path)\r\n-\r\n-        # Process the image\r\n-        processor = ImageProcessor()\r\n-        processed_image = processor.preprocess(image)\r\n-\r\n-        # Perform segmentation\r\n-        segmentation_result = perform_segmentation(processed_image)\r\n-\r\n-        # Calculate damage metrics\r\n-        damage_metrics = calculate_damage(segmentation_result)\r\n-\r\n-        # Generate visualization for the results\r\n-        # Ensure the results folder exists\r\n-        results_folder = os.path.join(current_app.static_folder, 'results')\r\n-        if not os.path.exists(results_folder):\r\n-            os.makedirs(results_folder)\r\n-        result_image_path = visualize_results(image, segmentation_result, results_folder)\r\n-\r\n-        # Create relative path for the result image to serve it\r\n-        # The base for relative path should be the static folder\r\n-        relative_result_path = os.path.relpath(result_image_path, current_app.static_folder)\r\n-        # Ensure forward slashes for URL\r\n-        relative_result_path = relative_result_path.replace('\\\\', '/')\r\n-\r\n-        return jsonify({\r\n-            'status': 'success',\r\n-            'damage_metrics': damage_metrics,\r\n-            'result_image': url_for('static', filename=relative_result_path)\r\n-        })\r\n-\r\n-    except Exception as e:\r\n-        # Log the exception for debugging\r\n-        current_app.logger.error(f\"Error processing image {image_path}: {e}\")\r\n-        return jsonify({'error': 'An internal error occurred during image processing.'}), 500\r\n-\r\n @app.route('/process_uploaded_images', methods=['POST'])\r\n def process_uploaded_images_route():\r\n     \"\"\"\r\n     Handles processing of uploaded top and front view images via POST request.\r\n-    Expects 'topImageFile' and 'frontImageFile' in request.files.\r\n     \"\"\"\r\n     start_time = time.time()\r\n     current_app.logger.info(\"Received request for /process_uploaded_images\")\r\n+    calculation_instance = Calculation()  # Instantiate per request\r\n \r\n-    top_file = request.files.get('topImageFile')\r\n-    front_file = request.files.get('frontImageFile')\r\n+    if 'topImageFile' not in request.files or 'frontImageFile' not in request.files:\r\n+        return jsonify({'error': \"Missing 'topImageFile' or 'frontImageFile' in request.\"}), 400\r\n \r\n+    top_file = request.files['topImageFile']\r\n+    front_file = request.files['frontImageFile']\r\n+\r\n+    if top_file.filename == '' or front_file.filename == '':\r\n+        return jsonify({'error': \"No file selected for top or front view.\"}), 400\r\n+\r\n     if top_file and allowed_file(top_file.filename) and front_file and allowed_file(front_file.filename):\r\n         try:\r\n-            # --- Get Upload Folder Path ---\r\n-            # Use the absolute path stored during init if available, otherwise construct it\r\n+            # --- Setup Folders ---\r\n             upload_folder = app.config.get('UPLOAD_FOLDER_ABS')\r\n-            if not upload_folder:  # Fallback if not set in config during init\r\n-                upload_folder_config = app.config.get('UPLOAD_FOLDER')\r\n-                # Assuming BASE_DIR is project root in config\r\n-                project_root = app.config.get('BASE_DIR', os.path.dirname(os.path.dirname(__file__)))\r\n-                upload_folder = os.path.join(project_root, upload_folder_config)\r\n-                current_app.logger.warning(f\"UPLOAD_FOLDER_ABS not found in config, constructed path: {upload_folder}\")\r\n-\r\n+            results_folder = os.path.join(current_app.static_folder, 'results')\r\n             if not upload_folder or not os.path.isdir(upload_folder):\r\n                 msg = f\"Upload folder is not configured correctly or does not exist: {upload_folder}\"\r\n                 current_app.logger.error(msg)\r\n                 return jsonify({'error': msg}), 500\r\n+            os.makedirs(results_folder, exist_ok=True)\r\n \r\n-            # --- Save Files ---\r\n+            # --- Save Original Files ---\r\n             ts = int(time.time())\r\n-            top_filename = secure_filename(f\"top_{ts}_{top_file.filename}\")\r\n-            front_filename = secure_filename(f\"front_{ts}_{front_file.filename}\")\r\n-            top_filepath = os.path.join(upload_folder, top_filename)\r\n-            front_filepath = os.path.join(upload_folder, front_filename)\r\n+            top_filename_orig = secure_filename(f\"top_{ts}_orig_{top_file.filename}\")\r\n+            front_filename_orig = secure_filename(f\"front_{ts}_orig_{front_file.filename}\")\r\n+            top_filepath_orig = os.path.join(upload_folder, top_filename_orig)\r\n+            front_filepath_orig = os.path.join(upload_folder, front_filename_orig)\r\n+            top_file.save(top_filepath_orig)\r\n+            front_file.save(front_filepath_orig)\r\n+            current_app.logger.info(f\"Saved original top image: {top_filepath_orig}\")\r\n+            current_app.logger.info(f\"Saved original front image: {front_filepath_orig}\")\r\n \r\n-            current_app.logger.info(f\"Saving top image to: {top_filepath}\")\r\n-            top_file.save(top_filepath)\r\n-            current_app.logger.info(f\"Saving front image to: {front_filepath}\")\r\n-            front_file.save(front_filepath)\r\n-\r\n             # --- Processing Pipeline ---\r\n-            # 1. Load\r\n+            # 1. Load Originals\r\n             loader = ImageLoader(image_dir=upload_folder)\r\n-            top_image = loader.load_image(top_filepath)\r\n-            front_image = loader.load_image(front_filepath)\r\n+            top_image_orig = loader.load_image(top_filepath_orig)\r\n+            front_image_orig = loader.load_image(front_filepath_orig)\r\n+            if top_image_orig is None or front_image_orig is None:\r\n+                raise ValueError(\"Failed to load one or both saved original images\")\r\n \r\n-            if top_image is None or front_image is None:\r\n-                raise ValueError(\"Failed to load one or both images\")\r\n-\r\n-            # 2. Preprocess (Adapt as needed)\r\n+            # 2. Preprocess\r\n             processor = ImageProcessor()\r\n-            processed_top = processor.preprocess_image(top_image)  # Assuming preprocess_image exists\r\n-            processed_front = processor.preprocess_image(front_image)\r\n+            processed_top = processor.preprocess_image(top_image_orig)\r\n+            processed_front = processor.preprocess_image(front_image_orig)\r\n             if processed_top is None or processed_front is None:\r\n                 raise ValueError(\"Failed to preprocess one or both images\")\r\n \r\n             # 3. Segment\r\n@@ -164,63 +89,86 @@\n             front_seg_data = perform_segmentation(processed_front)\r\n             if top_seg_data is None or front_seg_data is None:\r\n                 raise ValueError(\"Segmentation failed for one or both images\")\r\n \r\n-            # 4. Calculate Volume (Adapt based on actual function signature/return)\r\n-            calculation_result = calculate_volume(top_seg_data, front_seg_data)\r\n-            if calculation_result is None or 'volume' not in calculation_result:\r\n-                raise ValueError(\"Volume calculation failed or did not return volume\")\r\n-            calculated_volume = calculation_result['volume']\r\n-            calculated_points = calculation_result.get('points')  # Placeholder name\r\n+            # 4. Visualize Segmentation\r\n+            top_seg_viz_filename = f\"top_{ts}_seg.png\"\r\n+            front_seg_viz_filename = f\"front_{ts}_seg.png\"\r\n+            top_seg_viz_path = os.path.join(results_folder, top_seg_viz_filename)\r\n+            front_seg_viz_path = os.path.join(results_folder, front_seg_viz_filename)\r\n+            viz_top_success = visualize_segmentation(top_image_orig, top_seg_data, top_seg_viz_path)\r\n+            viz_front_success = visualize_segmentation(front_image_orig, front_seg_data, front_seg_viz_path)\r\n+            top_seg_url = url_for('static', filename=f'results/{top_seg_viz_filename}') if viz_top_success else None\r\n+            front_seg_url = url_for('static', filename=f'results/{front_seg_viz_filename}') if viz_front_success else None\r\n \r\n-            # 5. Visualize using the Class\r\n-            viz_relative_path = None\r\n+            # 5. Calculate Volume, Mass, Density using the Class instance\r\n+            material_type = request.form.get('materialType', 'Gravel')  # Default to Gravel\r\n+            condition = request.form.get('materialCondition', 'Loose')  # Default to Loose\r\n+            current_app.logger.info(f\"Using Material: {material_type}, Condition: {condition} for calculation.\")\r\n+\r\n+            calculation_result = calculation_instance.calculate_from_segmentation(\r\n+                top_seg_data, front_seg_data, material_type, condition\r\n+            )\r\n+\r\n+            if calculation_result is None:\r\n+                raise ValueError(\"Calculation failed (returned None)\")\r\n+\r\n+            # 6. Visualize 3D\r\n+            viz_3d_relative_path = None\r\n             try:\r\n                 visualizer = Visualizer()\r\n-                if calculated_points is not None:\r\n-                    visualizer.plot_cube(corners_3d=calculated_points, volume=calculated_volume)\r\n-                    results_folder = os.path.join(current_app.static_folder, 'results')\r\n-                    viz_filename = f\"visualization_{ts}.png\"\r\n-                    viz_abs_path = os.path.join(results_folder, viz_filename)\r\n-                    visualizer.save_figure(viz_abs_path)\r\n-                    viz_relative_path = os.path.join('results', viz_filename).replace('\\\\', '/')\r\n-                    current_app.logger.info(f\"Visualization saved to {viz_abs_path}\")\r\n+                visualizer.plot_cube(\r\n+                    corners_3d=calculation_result.get('points'),\r\n+                    volume=calculation_result.get('volume'),\r\n+                    density=calculation_result.get('density'),\r\n+                    mass=calculation_result.get('mass')  # Pass mass in KG\r\n+                )\r\n+                viz_3d_filename = f\"visualization_3d_{ts}.png\"\r\n+                viz_3d_abs_path = os.path.join(results_folder, viz_3d_filename)\r\n+                if visualizer.save_figure(viz_3d_abs_path):\r\n+                    viz_3d_relative_path = os.path.join('results', viz_3d_filename).replace('\\\\', '/')\r\n+                    current_app.logger.info(f\"3D Visualization saved to {viz_3d_abs_path}\")\r\n                 else:\r\n-                    current_app.logger.warning(\"No 3D points available from calculation for visualization.\")\r\n+                    current_app.logger.error(\"Failed to save 3D visualization figure.\")\r\n             except Exception as viz_err:\r\n-                current_app.logger.error(f\"Error during visualization: {viz_err}\", exc_info=True)\r\n+                current_app.logger.error(f\"Error during 3D visualization: {viz_err}\", exc_info=True)\r\n \r\n-            # 6. Prepare Response\r\n+            # 7. Prepare Response\r\n             processing_time = time.time() - start_time\r\n-            current_app.logger.info(f\"Processing complete. Volume: {calculated_volume}, Time: {processing_time:.2f}s\")\r\n-\r\n+            current_app.logger.info(f\"Processing complete. Time: {processing_time:.2f}s\")\r\n             response_data = {\r\n                 'status': 'success',\r\n-                'volume': calculated_volume,\r\n-                'unit': 'm³',\r\n+                'volume': calculation_result.get('volume'),\r\n+                'mass': calculation_result.get('mass'),  # Mass in KG\r\n+                'density': calculation_result.get('density'),  # Density in kg/m³\r\n+                'unit_volume': 'm³',\r\n+                'unit_mass': 'kg',\r\n+                'unit_density': 'kg/m³',\r\n                 'processing_time': round(processing_time, 2),\r\n                 'timestamp': time.strftime(\"%Y-%m-%d %H:%M:%S\"),\r\n-                'visualization_url': None\r\n+                'top_segmentation_url': top_seg_url,\r\n+                'front_segmentation_url': front_seg_url,\r\n+                'visualization_3d_url': url_for('static', filename=viz_3d_relative_path) if viz_3d_relative_path else None\r\n             }\r\n-            if viz_relative_path:\r\n-                response_data['visualization_url'] = url_for('static', filename=viz_relative_path)\r\n-\r\n             return jsonify(response_data)\r\n \r\n+        except ValueError as ve:\r\n+            current_app.logger.error(f\"Processing error: {ve}\", exc_info=True)\r\n+            if \"'float' is not iterable\" in str(ve):\r\n+                error_msg = \"Calculation error: Issue processing material density values.\"\r\n+            else:\r\n+                error_msg = f'Processing error: {ve}'\r\n+            return jsonify({'error': error_msg}), 500\r\n         except Exception as e:\r\n-            current_app.logger.error(f\"Error during image processing pipeline: {e}\", exc_info=True)\r\n-            return jsonify({'error': f'An internal error occurred: {e}'}), 500\r\n+            current_app.logger.error(f\"Unexpected error during image processing pipeline: {e}\", exc_info=True)\r\n+            if isinstance(e, TypeError) and \"'float' object is not iterable\" in str(e):\r\n+                error_msg = \"Internal calculation error: Issue processing material density values.\"\r\n+            else:\r\n+                error_msg = 'An internal server error occurred during processing.'\r\n+            return jsonify({'error': error_msg}), 500\r\n     else:\r\n-        allowed = app.config.get('ALLOWED_EXTENSIONS', set())\r\n-        msg = f\"Invalid file type. Allowed: {', '.join(allowed)}\"\r\n-        current_app.logger.error(msg)\r\n-        return jsonify({'error': msg}), 400\r\n+        return jsonify({'error': f\"Invalid file type. Allowed: {', '.join(ALLOWED_EXTENSIONS)}\"}), 400\r\n \r\n-@app.route('/about')\r\n-def about():\r\n-    \"\"\"Render the about page.\"\"\"\r\n-    return render_template('about.html')\r\n-\r\n @app.route('/api/health')\r\n def health_check():\r\n     \"\"\"API endpoint for health checks.\"\"\"\r\n     return jsonify({'status': 'ok'})\n\\ No newline at end of file\n"
                }
            ],
            "date": 1745145120355,
            "name": "Commit-0",
            "content": "from flask import render_template, request, jsonify, redirect, url_for, flash, current_app\r\nimport os\r\nfrom werkzeug.utils import secure_filename\r\nfrom App import app\r\nfrom App.Utils.ImageLoader import ImageLoader\r\nfrom App.Utils.ImageProcessor import ImageProcessor\r\nfrom App.Utils.segmentation import perform_segmentation\r\nfrom App.Utils.Calculation import calculate_damage\r\nfrom App.Utils.Visualizer import visualize_results\r\n\r\n# Helper function to check if a file has an allowed extension\r\ndef allowed_file(filename):\r\n    return '.' in filename and \\\r\n           filename.rsplit('.', 1)[1].lower() in current_app.config['ALLOWED_EXTENSIONS']\r\n\r\n@app.route('/')\r\ndef index():\r\n    \"\"\"Render the main page.\"\"\"\r\n    return render_template('main.html')\r\n\r\n@app.route('/upload', methods=['POST'])\r\ndef upload_file():\r\n    \"\"\"Handle file upload.\"\"\"\r\n    # Check if the post request has the file part\r\n    if 'file' not in request.files:\r\n        flash('No file part')\r\n        return redirect(request.url)\r\n\r\n    file = request.files['file']\r\n\r\n    # If user does not select file, browser also submits an empty part without filename\r\n    if file.filename == '':\r\n        flash('No selected file')\r\n        return redirect(request.url)\r\n\r\n    if file and allowed_file(file.filename):\r\n        filename = secure_filename(file.filename)\r\n        # Ensure the upload folder exists\r\n        upload_folder = current_app.config['UPLOAD_FOLDER']\r\n        if not os.path.exists(upload_folder):\r\n            os.makedirs(upload_folder)\r\n        filepath = os.path.join(upload_folder, filename)\r\n        file.save(filepath)\r\n\r\n        # Process the image and return results\r\n        return process_image(filepath)\r\n\r\n    flash('File type not allowed')\r\n    return redirect(url_for('index'))\r\n\r\n@app.route('/process', methods=['POST'])\r\ndef process_image_route():\r\n    \"\"\"Process an image with a provided path.\"\"\"\r\n    data = request.get_json()\r\n    image_path = data.get('image_path')\r\n\r\n    if not image_path or not os.path.exists(image_path):\r\n        return jsonify({'error': 'Invalid image path'}), 400\r\n\r\n    return process_image(image_path)\r\n\r\ndef process_image(image_path):\r\n    \"\"\"Process the image through the concrete damage detection pipeline.\"\"\"\r\n    try:\r\n        # Load the image\r\n        image_loader = ImageLoader()\r\n        image = image_loader.load_image(image_path)\r\n\r\n        # Process the image\r\n        processor = ImageProcessor()\r\n        processed_image = processor.preprocess(image)\r\n\r\n        # Perform segmentation\r\n        segmentation_result = perform_segmentation(processed_image)\r\n\r\n        # Calculate damage metrics\r\n        damage_metrics = calculate_damage(segmentation_result)\r\n\r\n        # Generate visualization for the results\r\n        # Ensure the results folder exists\r\n        results_folder = os.path.join(current_app.static_folder, 'results')\r\n        if not os.path.exists(results_folder):\r\n            os.makedirs(results_folder)\r\n        result_image_path = visualize_results(image, segmentation_result, results_folder)\r\n\r\n        # Create relative path for the result image to serve it\r\n        # The base for relative path should be the static folder\r\n        relative_result_path = os.path.relpath(result_image_path, current_app.static_folder)\r\n        # Ensure forward slashes for URL\r\n        relative_result_path = relative_result_path.replace('\\\\', '/')\r\n\r\n        return jsonify({\r\n            'status': 'success',\r\n            'damage_metrics': damage_metrics,\r\n            'result_image': url_for('static', filename=relative_result_path)\r\n        })\r\n\r\n    except Exception as e:\r\n        # Log the exception for debugging\r\n        current_app.logger.error(f\"Error processing image {image_path}: {e}\")\r\n        return jsonify({'error': 'An internal error occurred during image processing.'}), 500\r\n\r\n@app.route('/about')\r\ndef about():\r\n    \"\"\"Render the about page.\"\"\"\r\n    return render_template('about.html')\r\n\r\n@app.route('/api/health')\r\ndef health_check():\r\n    \"\"\"API endpoint for health checks.\"\"\"\r\n    return jsonify({'status': 'ok'})"
        }
    ]
}